{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@ayonli/jsext/webpack/universalModuleDefinition","webpack://@ayonli/jsext/./node_modules/check-iterable/index.js","webpack://@ayonli/jsext/./array/augment.ts","webpack://@ayonli/jsext/./array/index.ts","webpack://@ayonli/jsext/./augment.ts","webpack://@ayonli/jsext/./bundle.ts","webpack://@ayonli/jsext/./collections/BiMap.ts","webpack://@ayonli/jsext/./collections/CiMap.ts","webpack://@ayonli/jsext/./collections/augment.ts","webpack://@ayonli/jsext/./collections/index.ts","webpack://@ayonli/jsext/./error/Exception.ts","webpack://@ayonli/jsext/./error/augment.ts","webpack://@ayonli/jsext/./error/index.ts","webpack://@ayonli/jsext/./index.ts","webpack://@ayonli/jsext/./math/augment.ts","webpack://@ayonli/jsext/./math/index.ts","webpack://@ayonli/jsext/./number/augment.ts","webpack://@ayonli/jsext/./number/index.ts","webpack://@ayonli/jsext/./object/augment.ts","webpack://@ayonli/jsext/./object/index.ts","webpack://@ayonli/jsext/./promise/augment.ts","webpack://@ayonli/jsext/./promise/index.ts","webpack://@ayonli/jsext/./string/augment.ts","webpack://@ayonli/jsext/./string/index.ts","webpack://@ayonli/jsext/./uint8array/augment.ts","webpack://@ayonli/jsext/./uint8array/index.ts","webpack://@ayonli/jsext/external node-commonjs \"child_process\"","webpack://@ayonli/jsext/external node-commonjs \"events\"","webpack://@ayonli/jsext/external node-commonjs \"path\"","webpack://@ayonli/jsext/external node-commonjs \"url\"","webpack://@ayonli/jsext/external node-commonjs \"worker_threads\"","webpack://@ayonli/jsext/webpack/bootstrap","webpack://@ayonli/jsext/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@ayonli/jsext\"] = factory();\n\telse\n\t\troot[\"@ayonli/jsext\"] = factory();\n})(this, () => {\nreturn ","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isIterable = isIterable;\nexports.isAsyncIterable = isAsyncIterable;\nexports.isIteratorLike = isIteratorLike;\nexports.isIterableIterator = isIterableIterator;\nexports.isAsyncIterableIterator = isAsyncIterableIterator;\nexports.isGenerator = isGenerator;\nexports.isAsyncGenerator = isAsyncGenerator;\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nif (!Symbol.asyncIterator) {\n  Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\");\n}\n\n/**\n * Checks if the given object is an Iterable (implemented `@@iterator`).\n * @returns {obj is Iterable<any>}\n */\nfunction isIterable(obj) {\n  return obj !== null && obj !== undefined && typeof obj[Symbol.iterator] === \"function\";\n}\n\n/**\n * Checks if the given object is an AsyncIterable (implemented `@@asyncIterator`).\n * @returns {obj is AsyncIterable<any>}\n */\nfunction isAsyncIterable(obj) {\n  return obj !== null && obj !== undefined && typeof obj[Symbol.asyncIterator] === \"function\";\n}\n\n/**\n * Checks if the given object is an IteratorLike (implemented `next`).\n * @returns {obj is { next: Function }}\n */\nfunction isIteratorLike(obj) {\n  // An iterable object has a 'next' method, however including a 'next' method\n  // doesn't ensure the object is an iterator, it is only iterator-like.\n  return _typeof(obj) === \"object\" && obj !== null && typeof obj.next === \"function\";\n}\n\n/**\n * Checks if the given object is an IterableIterator (implemented both\n * `@@iterator` and `next`).\n */\nfunction isIterableIterator(obj) {\n  return isIteratorLike(obj) && typeof obj[Symbol.iterator] === \"function\";\n}\n\n/**\n * Checks if the given object is an AsyncIterableIterator (implemented\n * both `@@asyncIterator` and `next`).\n * @returns {obj is AsyncIterableIterator<any>}\n */\nfunction isAsyncIterableIterator(obj) {\n  return isIteratorLike(obj) && typeof obj[Symbol.asyncIterator] === \"function\";\n}\n\n/**\n * Checks if the given object is a Generator.\n * @returns {obj is Generator}\n */\nfunction isGenerator(obj) {\n  return isIterableIterator(obj) && hasGeneratorSpecials(obj);\n}\n\n/**\n * Checks if the given object is an AsyncGenerator.\n * @returns {obj is AsyncGenerator}\n */\nfunction isAsyncGenerator(obj) {\n  return isAsyncIterableIterator(obj) && hasGeneratorSpecials(obj);\n}\nfunction hasGeneratorSpecials(obj) {\n  return typeof obj[\"return\"] === \"function\" && typeof obj[\"throw\"] === \"function\";\n}\n","import {\n    chunk as _chunk,\n    count as _count,\n    equals as _equals,\n    groupBy as _groupBy,\n    orderBy as _orderBy,\n    shuffle as _shuffle,\n    split as _split,\n    uniq as _uniq\n} from \".\";\n\ndeclare global {\n    interface Array<T> {\n        /** Returns the first element of the array, or `undefined` if the array is empty. */\n        first(): T;\n        /** Returns the last element of the array, or `undefined` is the array is empty. */\n        last(): T;\n        /** Counts the occurrence of the element in the array. */\n        count(ele: T): number;\n        /**\n         * Performs a shallow compare to another array and see if it contains the same elements as\n         * this array.\n         */\n        equals(another: T[]): boolean;\n        /** Breaks the array into smaller chunks according to the given delimiter. */\n        split(delimiter: T): T[][];\n        /** Breaks the array into smaller chunks according to the given length. */\n        chunk(length: number): T[][];\n        /** Returns a subset of the array that contains only unique items. */\n        uniq(): T[];\n        /**\n         * Reorganizes the elements in the array in random order.\n         * \n         * This function mutates the array.\n         */\n        shuffle(): T[];\n        toShuffled(): T[];\n        toReversed(): T[];\n        toSorted(fn?: ((a: T, b: T) => number) | undefined): T[];\n        /**\n         * Orders the items of the array according to the specified comparable `key` (whose value\n         * must either be a numeric or string).\n         */\n        orderBy(key: keyof T, order?: \"asc\" | \"desc\"): T[];\n        /**\n         * Groups the items of the array according to the comparable values returned by a provided\n         * callback function.\n         * The returned record / map has separate properties for each group, containing arrays with\n         * the items in the group.\n         */\n        groupBy(fn: (item: T, i: number) => string | symbol, type?: ObjectConstructor): Record<string | symbol, T[]>;\n        groupBy<K>(fn: (item: T, i: number) => K, type: MapConstructor): Map<K, T[]>;\n    }\n}\n\nArray.prototype.first = function first() {\n    return this[0];\n};\n\nArray.prototype.last = function last() {\n    return this[this.length - 1];\n};\n\nArray.prototype.count = function count(ele) {\n    return _count(this, ele);\n};\n\nArray.prototype.equals = function equals(another) {\n    return _equals(this, another);\n};\n\nArray.prototype.split = function split(delimiter) {\n    return _split(this, delimiter) as any[];\n};\n\nArray.prototype.chunk = function chunk(length) {\n    return _chunk(this, length) as any[];\n};\n\nArray.prototype.uniq = function uniq() {\n    return _uniq(this);\n};\n\nArray.prototype.shuffle = function shuffle() {\n    return _shuffle(this);\n};\n\nArray.prototype.toShuffled = function toShuffled() {\n    return this.slice().shuffle();\n};\n\nif (!Array.prototype.toReversed) {\n    Array.prototype.toReversed = function toReversed() {\n        return this.slice().reverse();\n    };\n}\n\nif (!Array.prototype.toSorted) {\n    Array.prototype.toSorted = function toSorted(fn) {\n        return this.slice().sort(fn);\n    };\n}\n\nArray.prototype.orderBy = function orderBy(key, order = \"asc\") {\n    return _orderBy(this, key, order);\n};\n\nArray.prototype.groupBy = function orderBy(\n    fn: (item: any, i: number) => any,\n    type: ObjectConstructor | MapConstructor = Object\n): any {\n    return _groupBy(this, fn, type as any);\n};\n","export interface RealArrayLike<T> extends ArrayLike<T> {\n    slice(start?: number, end?: number): RealArrayLike<T>;\n}\n\n/** Counts the occurrence of the element in the array. */\nexport function count<T>(arr: RealArrayLike<T>, ele: T): number {\n    let count = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === ele) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n/**\n * Performs a shallow compare to another array and see if it contains the same elements as\n * this array.\n */\nexport function equals<T>(arr1: RealArrayLike<T>, arr2: RealArrayLike<T>): boolean {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/** Breaks the array into smaller chunks according to the given delimiter. */\nexport function split<T>(arr: RealArrayLike<T>, delimiter: T): RealArrayLike<T>[] {\n    const chunks: (typeof arr)[] = [];\n    const limit = arr.length;\n    let offset = 0;\n\n    for (let i = 0; i < limit; i++) {\n        if (arr[i] === delimiter) {\n            chunks.push(arr.slice(offset, i));\n            offset = i + 1;\n        }\n    }\n\n    if (offset < limit) {\n        chunks.push(arr.slice(offset, limit));\n    } else if (offset === limit) {\n        const ctor = arr.constructor as (new (...args: any[]) => RealArrayLike<T>) & {\n            from?: (iterable: Iterable<T>) => RealArrayLike<T>;\n        };\n\n        if (typeof ctor.from === \"function\") {\n            chunks.push(ctor.from([]));\n        } else {\n            chunks.push(new ctor([]));\n        }\n    }\n\n    return chunks;\n}\n\n/** Breaks the array into smaller chunks according to the given length. */\nexport function chunk<T>(arr: RealArrayLike<T>, length: number): RealArrayLike<T>[] {\n    const limit = arr.length;\n    const size = Math.ceil(limit / length);\n    const chunks = new Array<RealArrayLike<T>>(size);\n    let offset = 0;\n    let idx = 0;\n\n    while (offset < limit) {\n        chunks[idx] = arr.slice(offset, offset + length);\n        offset += length;\n        idx++;\n    }\n\n    return chunks;\n}\n\n/** Returns a subset of the array that contains only unique items. */\nexport function uniq<T>(arr: T[]): T[] {\n    return [...new Set(arr)];\n}\n\n/**\n * Reorganizes the elements in the array in random order.\n * \n * This function mutates the array.\n */\nexport function shuffle<T>(arr: T[]): T[] {\n    for (let i = arr.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [arr[i], arr[j]] = [arr[j] as T, arr[i] as T];\n    }\n\n    return arr;\n}\n\n/**\n * Orders the items of the array according to the specified comparable `key` (whose value\n * must either be a numeric or string).\n */\nexport function orderBy<T>(arr: T[], key: keyof T, order: \"asc\" | \"desc\" = \"asc\"): T[] {\n    const items = arr.slice();\n    items.sort((a, b) => {\n        if (typeof a !== \"object\" || typeof b !== \"object\" ||\n            !a || !b ||\n            Array.isArray(a) || Array.isArray(b)\n        ) {\n            return -1;\n        }\n\n        const _a = a[key];\n        const _b = b[key];\n\n        if (_a === undefined || _b === undefined) {\n            return -1;\n        }\n\n        if (typeof _a === \"number\" && typeof _b === \"number\") {\n            return _a - _b;\n        } else if ((typeof _a === \"string\" && typeof _b === \"string\")\n            || (typeof _a === \"bigint\" && typeof _b === \"bigint\")\n        ) {\n            if (_a < _b) {\n                return -1;\n            } else if (_a > _b) {\n                return 1;\n            } else {\n                return 1;\n            }\n        } else {\n            return -1;\n        }\n    });\n\n    if (order === \"desc\") {\n        items.reverse();\n    }\n\n    return items;\n};\n\n/**\n * Groups the items of the array according to the comparable values returned by a provided\n * callback function.\n * The returned record / map has separate properties for each group, containing arrays with\n * the items in the group.\n */\nexport function groupBy<T>(\n    arr: T[],\n    fn: (item: T, i: number) => string | symbol,\n    type?: ObjectConstructor\n): Record<string | symbol, T[]>;\nexport function groupBy<T, K extends string>(\n    arr: T[],\n    fn: (item: T, i: number) => K,\n    type: MapConstructor\n): Map<K, T[]>;\nexport function groupBy<T>(\n    arr: T[],\n    fn: (item: T, i: number) => any,\n    type: ObjectConstructor | MapConstructor = Object\n): any {\n    if (type === Map) {\n        const groups = new Map<any, any[]>();\n\n        for (let i = 0; i < arr.length; i++) {\n            const item = arr[i];\n            const key = fn(item as T, i);\n            const list = groups.get(key);\n\n            if (list) {\n                list.push(item);\n            } else {\n                groups.set(key, [item]);\n            }\n        }\n\n        return groups;\n    } else {\n        const groups: Record<string | symbol, any[]> = {};\n\n        for (let i = 0; i < arr.length; i++) {\n            const item = arr[i];\n            const key = fn(item as T, i);\n            const list = groups[key];\n\n            if (list) {\n                list.push(item);\n            } else {\n                groups[key] = [item];\n            }\n        }\n\n        return groups;\n    }\n};\n","import \"./string/augment\";\nimport \"./number/augment\";\nimport \"./array/augment\";\nimport \"./uint8array/augment\";\nimport \"./object/augment\";\nimport \"./math/augment\";\nimport \"./promise/augment\";\nimport \"./collections/augment\";\nimport \"./error/augment\";\n\ndeclare global {\n    interface Constructor<T> extends Function {\n        new(...args: any[]): T;\n        prototype: T;\n    }\n\n    interface TypedArray extends Array<number> {\n        readonly buffer: ArrayBufferLike;\n        readonly byteLength: number;\n        subarray(begin?: number, end?: number): TypedArray;\n    }\n\n    type Optional<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;\n    type Ensured<T, K extends keyof T> = Required<Pick<T, K>> & Omit<T, K>;\n}\n","import \"./augment\";\nimport jsext from \"./index\";\n\nexport = jsext;\n","const inverse = Symbol(\"inverse\");\n\n/** Bi-directional map, keys and values are unique and map to each other. */\nexport default class BiMap<K, V> extends Map<K, V> {\n    [inverse]: Map<V, K>;\n\n    get [Symbol.toStringTag]() {\n        return \"BiMap\";\n    }\n\n    constructor(iterable: Iterable<readonly [K, V]> | null = null) {\n        super();\n        this[inverse] = new Map<V, K>();\n\n        if (iterable) {\n            for (const [key, value] of iterable) {\n                this.set(key, value);\n            }\n        }\n    }\n\n    override set(key: K, value: V): this {\n        super.set(key, value);\n        this[inverse].set(value, key);\n        return this;\n    }\n\n    getKey(value: V): K | undefined {\n        return this[inverse].get(value);\n    }\n\n    hasValue(value: V): boolean {\n        return this[inverse].has(value);\n    }\n\n    deleteValue(value: V): boolean {\n        if (this[inverse].has(value)) {\n            const key = this[inverse].get(value) as K;\n            super.delete(key);\n            this[inverse].delete(value);\n            return true;\n        }\n\n        return false;\n    }\n\n    override clear(): void {\n        super.clear();\n        this[inverse].clear();\n    }\n}\n","const internal = Symbol(\"internal\");\n\n/** Case-insensitive map, keys are case-insensitive. */\nexport default class CiMap<K extends string, V> implements Map<K, V> {\n    [internal]: Map<string, { key: K, value: V; }>;\n\n    get [Symbol.toStringTag]() {\n        return \"CiMap\";\n    }\n\n    get size() {\n        return this[internal].size;\n    }\n\n    constructor(iterable: Iterable<readonly [K, V]> | null = null) {\n        this[internal] = new Map<string, { key: K, value: V; }>();\n\n        if (iterable) {\n            for (const [key, value] of iterable) {\n                this.set(key, value);\n            }\n        }\n    }\n\n    set(key: K, value: V): this {\n        const id = String(key).toLowerCase();\n        this[internal].set(id, { key, value });\n        return this;\n    }\n\n    get(key: K): V | undefined {\n        const id = String(key).toLowerCase();\n        return this[internal].get(id)?.value;\n    }\n\n    has(key: K): boolean {\n        const id = String(key).toLowerCase();\n        return this[internal].has(id);\n    }\n\n    delete(key: K): boolean {\n        const id = String(key).toLowerCase();\n        return this[internal].delete(id);\n    }\n\n    clear(): void {\n        this[internal].clear();\n    }\n\n    * entries(): IterableIterator<[K, V]> {\n        for (const { key, value } of this[internal].values()) {\n            yield [key, value];\n        }\n    }\n\n    * keys(): IterableIterator<K> {\n        for (const { key } of this[internal].values()) {\n            yield key;\n        }\n    }\n\n    * values(): IterableIterator<V> {\n        for (const { value } of this[internal].values()) {\n            yield value;\n        }\n    }\n\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\n        this[internal].forEach(({ key, value }) => {\n            callbackfn(value, key, this);\n        }, thisArg);\n    }\n\n    [Symbol.iterator](): IterableIterator<[K, V]> {\n        return this.entries();\n    }\n}\n","\nimport { BiMap, CiMap } from \".\";\n\ndeclare global {\n    class BiMap<K, V> extends Map<K, V> {\n        getKey(value: V): K | undefined;\n        hasValue(value: V): boolean;\n        deleteValue(value: V): boolean;\n    }\n\n    class CiMap<K extends string, V> implements Map<K, V> {\n        readonly [Symbol.toStringTag]: \"CiMap\";\n        readonly size: number;\n        constructor(iterable?: Iterable<readonly [K, V]> | null);\n        set(key: K, value: V): this;\n        get(key: K): V | undefined;\n        has(key: K): boolean;\n        delete(key: K): boolean;\n        clear(): void;\n        entries(): IterableIterator<[K, V]>;\n        keys(): IterableIterator<K>;\n        values(): IterableIterator<V>;\n        forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;\n        [Symbol.iterator](): IterableIterator<[K, V]>;\n    }\n}\n\n// @ts-ignore\nglobalThis[\"BiMap\"] = BiMap;\n// @ts-ignore\nglobalThis[\"CiMap\"] = CiMap;\n","import BiMap from \"./BiMap\";\nimport CiMap from \"./CiMap\";\n\nexport { BiMap, CiMap };\n","export default class Exception extends Error {\n    readonly cause?: unknown;\n    readonly code: number = 0;\n\n    constructor(message: string, code?: number);\n    constructor(message: string, options: { cause?: unknown; code: number; });\n    constructor(message: string, options: number | { cause?: unknown; code?: number; } = 0) {\n        super(message);\n\n        if (typeof options === \"number\") {\n            this.code = options;\n        } else {\n            if (options.cause) {\n                Object.defineProperty(this, \"cause\", {\n                    configurable: true,\n                    enumerable: false,\n                    writable: true,\n                    value: options.cause,\n                });\n            }\n\n            if (options.code) {\n                this.code = options.code;\n            }\n        }\n    }\n}\n\nObject.defineProperty(Exception.prototype, \"name\", {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: \"Exception\",\n});\n","import { Exception, fromObject, toObject } from \".\";\n\ndeclare global {\n    interface Error {\n        toJSON(): { [x: string]: any; };\n    }\n\n    interface ErrorConstructor {\n        /** Transform the error to a plain object. */\n        toObject<T extends Error>(err: T): { [x: string | symbol]: any; }\n        /** Reverse a plain object to a specific error type according to the `name` property. */\n        fromObject<T extends { name: \"Error\"; }>(obj: T): Error;\n        fromObject<T extends { name: \"EvalError\"; }>(obj: T): EvalError;\n        fromObject<T extends { name: \"RangeError\"; }>(obj: T): RangeError;\n        fromObject<T extends { name: \"ReferenceError\"; }>(obj: T): ReferenceError;\n        fromObject<T extends { name: \"SyntaxError\"; }>(obj: T): SyntaxError;\n        fromObject<T extends { name: \"TypeError\"; }>(obj: T): TypeError;\n        fromObject<T extends { name: \"URIError\"; }>(obj: T): URIError;\n        fromObject<T extends { name: \"Exception\"; }>(obj: T): Exception;\n        fromObject<T extends Error>(obj: { [x: string | symbol]: any; }): T;\n    }\n\n    class Exception extends Error {\n        readonly cause?: unknown;\n        readonly code: number;\n        constructor(message: string, code?: number);\n        constructor(message: string, options: { cause?: unknown; code?: number; });\n    }\n}\n\n//@ts-ignore\nglobalThis[\"Exception\"] = Exception;\n\nError.toObject = toObject\nError.fromObject = fromObject;\n\nError.prototype.toJSON = function toJSON() {\n    return toObject(this);\n};\n","import { omit } from \"../object\";\nimport Exception from \"./Exception\";\n\nexport { Exception };\n\n/** Transform the error to a plain object. */\nexport function toObject<T extends Error>(err: T): { [x: string | symbol]: any; } {\n    return omit(err, []);\n}\n\n/** Reverse a plain object to a specific error type according to the `name` property. */\nexport function fromObject<T extends { name: \"Error\"; }>(obj: T): Error;\nexport function fromObject<T extends { name: \"EvalError\"; }>(obj: T): EvalError;\nexport function fromObject<T extends { name: \"RangeError\"; }>(obj: T): RangeError;\nexport function fromObject<T extends { name: \"ReferenceError\"; }>(obj: T): ReferenceError;\nexport function fromObject<T extends { name: \"SyntaxError\"; }>(obj: T): SyntaxError;\nexport function fromObject<T extends { name: \"TypeError\"; }>(obj: T): TypeError;\nexport function fromObject<T extends { name: \"URIError\"; }>(obj: T): URIError;\nexport function fromObject<T extends { name: \"Exception\"; }>(obj: T): Exception;\nexport function fromObject<T extends Error>(obj: { [x: string | symbol]: any; }): T;\nexport function fromObject<T extends Error>(obj: { [x: string | symbol]: any; }): T {\n    // @ts-ignore\n    let ctor = globalThis[obj.name] as new (...args: any) => T;\n\n    if (!ctor) {\n        if (obj[\"name\"] === \"Exception\") {\n            ctor = Exception as unknown as new (...args: any) => T;\n        } else {\n            ctor = Error as unknown as new (...args: any) => T;\n        }\n    }\n\n    const err: T = Object.create(ctor.prototype, {\n        message: {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: obj[\"message\"] ?? \"\",\n        },\n    });\n\n    if (err.name !== obj[\"name\"]) {\n        Object.defineProperty(err, \"name\", {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: obj[\"name\"],\n        });\n    }\n\n    if (obj[\"stack\"] !== undefined) {\n        Object.defineProperty(err, \"stack\", {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: obj[\"stack\"],\n        });\n    }\n\n    if (obj[\"cause\"] != undefined) {\n        Object.defineProperty(err, \"cause\", {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: obj[\"cause\"],\n        });\n    }\n\n    const otherKeys = Reflect.ownKeys(obj).filter(\n        key => !([\"name\", \"message\", \"stack\", \"cause\"] as (string | symbol)[]).includes(key)\n    );\n\n    otherKeys.forEach(key => {\n        // @ts-ignore\n        err[key] = obj[key];\n    });\n\n    return err;\n}\n","import { isAsyncGenerator, isGenerator } from \"check-iterable\";\nimport type { Worker as NodeWorker } from \"worker_threads\";\nimport type { ChildProcess } from \"child_process\";\nimport { sequence } from \"./number\";\n\nexport interface Constructor<T> extends Function {\n    new(...args: any[]): T;\n    prototype: T;\n}\n\nexport interface TypedArray extends Array<number> {\n    readonly buffer: ArrayBufferLike;\n    readonly byteLength: number;\n    subarray(begin?: number, end?: number): TypedArray;\n}\n\nexport type Optional<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;\nexport type Ensured<T, K extends keyof T> = Required<Pick<T, K>> & Omit<T, K>;\n\nexport type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n\nconst isNode = typeof process === \"object\" && !!process.versions?.node;\ndeclare var Deno: any;\n\ntype ThrottleCache = {\n    for: any;\n    expires?: number;\n    result?: { value?: any; error?: unknown; };\n};\nconst throttleCaches = new Map<any, ThrottleCache>();\n\n/**\n * The maximum number of workers allowed to exist at the same time.\n * \n * The primary purpose of the workers is not mean to run tasks in parallel, but run them in separate\n * from the main thread, so that aborting tasks can be achieved by terminating the worker thread and\n * it will not affect the main thread.\n * \n * That said, the worker thread can still be used to achieve parallelism, but it should be noticed\n * that only the numbers of tasks that equals to the CPU core numbers will be run at the same time.\n */\nconst maxWorkerNum = 16;\n\nconst workerIdCounter = sequence(1, Number.MAX_SAFE_INTEGER, 1, true);\nlet workerPool: {\n    workerId: number;\n    worker: Worker | NodeWorker | ChildProcess;\n    adapter: \"worker_threads\" | \"child_process\";\n    busy: boolean;\n}[] = [];\n\n// The worker consumer queue is nothing but a callback list, once a worker is available, the runner\n// pop a consumer and run the callback, which will retry gaining the worker and retry the task.\nconst workerConsumerQueue: (() => void)[] = [];\n\n/**\n * Merges properties and methods only if they're missing in the class. \n */\nfunction mergeIfNotExists(proto: object, source: object, mergeSuper = false) {\n    const props = Reflect.ownKeys(source);\n\n    for (const prop of props) {\n        if (prop == \"constructor\") {\n            continue;\n        } else if (mergeSuper) {\n            // When merging properties from super classes, the properties in the\n            // base class has the first priority and shall not be overwrite.\n            if (!(prop in proto)) {\n                setProp(proto, source, <string | symbol>prop);\n            }\n        } else if (!proto.hasOwnProperty(prop)) {\n            setProp(proto, source, <string | symbol>prop);\n        }\n    }\n\n    return proto;\n}\n\n/**\n * Merges properties and methods across the prototype chain.\n */\nfunction mergeHierarchy(ctor: Function, mixin: Function, mergeSuper = false) {\n    mergeIfNotExists(ctor.prototype, mixin.prototype, mergeSuper);\n\n    const _super = Object.getPrototypeOf(mixin);\n\n    // Every user defined class or functions that can be instantiated have their\n    // own names, if no name appears, that means the function has traveled to \n    // the root of the hierarchical tree.\n    if (_super.name) {\n        mergeHierarchy(ctor, _super, true);\n    }\n}\n\n/**\n * Sets property for prototype based on the given source and prop name properly.\n */\nfunction setProp(proto: any, source: any, prop: string | symbol) {\n    const desc = Object.getOwnPropertyDescriptor(source, prop);\n\n    if (desc) {\n        Object.defineProperty(proto, prop, desc);\n    } else {\n        proto[prop] = source[prop];\n    }\n}\n\nexport interface JsExt {\n    /**\n     * Runs a function and catches any error happens inside it, returns the error and result\n     * in a `[err, res]` tuple.\n     */\n    try<E = Error, T = any, A extends any[] = any[], TReturn = any, TNext = unknown>(\n        fn: (...args: A) => AsyncGenerator<T, TReturn, TNext>,\n        ...args: A\n    ): AsyncGenerator<[E | null, T], [E | null, TReturn], TNext>;\n    try<E = Error, T = any, A extends any[] = any[], TReturn = any, TNext = unknown>(\n        fn: (...args: A) => Generator<T, TReturn, TNext>,\n        ...args: A\n    ): Generator<[E | null, T], [E | null, TReturn], TNext>;\n    try<E = Error, R = any, A extends any[] = any[]>(\n        fn: (...args: A) => Promise<R>,\n        ...args: A\n    ): Promise<[E | null, R]>;\n    try<E = Error, R = any, A extends any[] = any[]>(\n        fn: (...args: A) => R,\n        ...args: A\n    ): [E | null, R];\n    /** Resolves a generator and renders its yield value in a `[err, val]` tuple. */\n    try<E = Error, T = any, TReturn = any, TNext = unknown>(\n        gen: AsyncGenerator<T, TReturn, TNext>\n    ): AsyncGenerator<[E | null, T], [E | null, TReturn], TNext>;\n    try<E = Error, T = any, TReturn = any, TNext = unknown>(\n        gen: Generator<T, TReturn, TNext>\n    ): Generator<[E | null, T], [E | null, TReturn], TNext>;\n    /** Resolves a promise and returns the error and result in a `[err, res]` tuple. */\n    try<E = Error, R = any>(job: Promise<R>): Promise<[E | null, R]>;\n\n    /**\n     * Inspired by Golang, creates a function that receives a `defer` function which can be used\n     * to carry deferred jobs that will be run after the main function is complete.\n     * \n     * Multiple calls of the `defer` function is supported, and the callbacks are called in the\n     * LIFO order. Callbacks can be async functions if the main function is an async function or\n     * an async generator function, and all the running procedures will be awaited.\n     * \n     * @example\n     *  const getVersion = await jsext.func(async (defer) => {\n     *      const file = await fs.open(\"./package.json\", \"r\");\n     *      defer(() => file.close());\n     *\n     *      const content = await file.readFile(\"utf8\");\n     *      const pkg = JSON.parse(content);\n     *\n     *      return pkg.version as string;\n     *  });\n     */\n    func<T, R = any, A extends any[] = any[]>(\n        fn: (this: T, defer: (cb: () => void) => void, ...args: A) => R\n    ): (this: T, ...args: A) => R;\n\n    /**\n     * Wraps a function inside another function and returns a new function\n     * that copies the original function's name and properties.\n     */\n    wrap<T, Fn extends (this: T, ...args: any[]) => any>(\n        fn: Fn,\n        wrapper: (this: T, fn: Fn, ...args: Parameters<Fn>) => ReturnType<Fn>\n    ): Fn;\n\n    /**\n     * Creates a throttled function that will only be run once in a certain amount of time.\n     * \n     * If a subsequent call happens within the `duration`, the previous result will be returned and\n     * the `handler` function will not be invoked.\n     */\n    throttle<T, Fn extends (this: T, ...args: any[]) => any>(handler: Fn, duration: number): Fn;\n    throttle<T, Fn extends (this: T, ...args: any[]) => any>(handler: Fn, options: {\n        duration: number;\n        /**\n         * Use the throttle strategy `for` the given key, this will keep the result in a global\n         * cache, binding new `handler` function for the same key will result in the same result\n         * as the previous, unless the duration has passed. This mechanism guarantees that both\n         * creating the throttled function in function scopes and overwriting the handler are\n         * possible.\n         */\n        for?: any;\n    }): Fn;\n\n    /**\n     * Returns an extended class that combines all mixin methods.\n     * \n     * This function does not mutates the base class but create a pivot class\n     * instead.\n     */\n    mixins<T extends Constructor<any>, M extends any[]>(\n        base: T,\n        ...mixins: { [X in keyof M]: Constructor<M[X]> }\n    ): T & Constructor<UnionToIntersection<FlatArray<M, 1>>>;\n    mixins<T extends Constructor<any>, M extends any[]>(\n        base: T,\n        ...mixins: M\n    ): T & Constructor<UnionToIntersection<FlatArray<M, 1>>>;\n\n    /** Checks if a class is a subclass of another class. */\n    isSubclassOf<T, B>(ctor1: Constructor<T>, ctor2: Constructor<B>): boolean;\n\n    /**\n     * Wraps a source as an AsyncIterable object that can be used in the `for...await...` loop\n     * for reading streaming data.\n     */\n    read<I extends AsyncIterable<any>>(iterable: I): I;\n    read(es: EventSource, options?: { event?: string; }): AsyncIterable<string>;\n    read<T extends Uint8Array | string>(ws: WebSocket): AsyncIterable<T>;\n    read<T>(target: EventTarget, eventMap?: {\n        message?: string;\n        error?: string;\n        close?: string;\n    }): AsyncIterable<T>;\n    read<T>(target: NodeJS.EventEmitter, eventMap?: {\n        data?: string;\n        error?: string;\n        close?: string;\n    }): AsyncIterable<T>;\n\n    /**\n     * Runs a task in the `script` in a worker thread that can be aborted during runtime.\n     * \n     * In Node.js, the `script` can be either a CommonJS module or an ES module, and is relative to\n     * the current working directory if not absolute.\n     * \n     * In browser or Deno, the `script` can only be an ES module, and is relative to the current URL\n     * (or working directory for Deno) if not absolute.\n     */\n    run<T, A extends any[] = any[]>(script: string, args?: A, options?: {\n        /** If not set, runs the default function, otherwise runs the specific function. */\n        fn?: string;\n        /** Automatically abort the task when timeout (in milliseconds). */\n        timeout?: number;\n        /**\n         * Instead of dropping the worker after the task has completed, keep it alive so that it can\n         * be reused by other tasks.\n         */\n        keepAlive?: boolean;\n        /**\n         * Choose whether to use `worker_threads` or `child_process` fron running the script.\n         * The default setting is `worker_threads`.\n         * \n         * In browser or Deno, this option is ignored and will always use the web worker.\n         */\n        adapter?: \"worker_threads\" | \"child_process\";\n        /**\n         * In browser or Deno, by default, the program loads the worker entry directly from GitHub,\n         * which could be slow due to poor internet connection, we can copy the entry file\n         * `esm/worker-web.mjs` to a local path of our website and set this option to that path so\n         * that it can be loaded locally.\n         */\n        webWorkerEntry?: string;\n    }): Promise<{\n        workerId: number;\n        /** Terminates the worker and abort the task. */\n        abort(): Promise<void>;\n        /** Retrieves the return value of the function. */\n        result(): Promise<T>;\n        /** Iterates the yield value if the function returns a generator. */\n        iterate(): AsyncIterable<T>;\n    }>;\n}\n\nconst jsext: JsExt = {\n    try(fn: any, ...args: any[]) {\n        if (typeof fn === \"function\") {\n            try {\n                return jsext.try(fn.apply(void 0, args));\n            } catch (err) {\n                return [err, undefined];\n            }\n        }\n\n        let returns = fn;\n        // Implementation details should be ordered from complex to simple.\n\n        if (isAsyncGenerator(returns)) {\n            return (async function* () {\n                let input: unknown;\n                let result: any;\n\n                // Use `while` loop instead of `for...of...` in order to\n                // retrieve the return value of a generator function.\n                while (true) {\n                    try {\n                        const { done, value } = await returns.next(input);\n\n                        if (done) {\n                            result = value;\n                            break;\n                        } else {\n                            // Receive any potential input value that passed\n                            // to the outer `next()` call, and pass them to\n                            // `res.next()` in the next call.\n                            input = yield Promise.resolve([null, value]);\n                        }\n                    } catch (err) {\n                        // If any error occurs, yield that error as resolved\n                        // and break the loop immediately, indicating the\n                        // process is forced broken.\n                        yield Promise.resolve([err, undefined]);\n                        break;\n                    }\n                }\n\n                return [null, result];\n            })() as AsyncGenerator<unknown, any, unknown>;\n        } else if (isGenerator(returns)) {\n            return (function* () {\n                let input: unknown;\n                let result: any;\n\n                while (true) {\n                    try {\n                        const { done, value } = returns.next(input);\n\n                        if (done) {\n                            result = value;\n                            break;\n                        } else {\n                            input = yield [null, value];\n                        }\n                    } catch (err) {\n                        yield [err, undefined];\n                        break;\n                    }\n                }\n\n                return [null, result];\n            })() as Generator<unknown, any, unknown>;\n        } else if (typeof returns?.then === \"function\") {\n            returns = (returns as PromiseLike<any>).then((value: any) => [null, value]);\n            return Promise.resolve(returns).catch((err: unknown) => [err, undefined]) as any;\n        } else {\n            return [null, returns];\n        }\n    },\n    func<T, R = any, A extends any[] = any[]>(\n        fn: (this: T, defer: (cb: () => void) => void, ...args: A) => R\n    ): (this: T, ...args: A) => R {\n        return function (this: any, ...args: A) {\n            const callbacks: (() => void)[] = [];\n            const defer = (cb: () => void) => void callbacks.push(cb);\n            type Result = { value?: Awaited<R>; error: unknown; };\n            let result: Result | undefined;\n\n            try {\n                const returns = fn.call(this, defer, ...args) as any;\n\n                if (isAsyncGenerator(returns)) {\n                    const gen = (async function* () {\n                        let input: unknown;\n\n                        // Use `while` loop instead of `for...of...` in order to\n                        // retrieve the return value of a generator function.\n                        while (true) {\n                            try {\n                                const { done, value } = await returns.next(input);\n\n                                if (done) {\n                                    result = { value, error: null };\n                                    break;\n                                } else {\n                                    // Receive any potential input value that passed\n                                    // to the outer `next()` call, and pass them to\n                                    // `res.next()` in the next call.\n                                    input = yield Promise.resolve(value);\n                                }\n                            } catch (error) {\n                                // If any error occurs, capture that error and break\n                                // the loop immediately, indicating the process is\n                                // forced broken.\n                                result = { value: void 0, error } as Result;\n                                break;\n                            }\n                        }\n\n                        for (let i = callbacks.length - 1; i >= 0; i--) {\n                            await (callbacks[i] as () => void | Promise<void>)?.();\n                        }\n\n                        if (result.error) {\n                            throw result.error;\n                        } else {\n                            return result.value;\n                        }\n                    })() as AsyncGenerator<unknown, any, unknown>;\n\n                    return gen as R;\n                } else if (isGenerator(returns)) {\n                    const gen = (function* () {\n                        let input: unknown;\n\n                        while (true) {\n                            try {\n                                const { done, value } = returns.next(input);\n\n                                if (done) {\n                                    result = { value, error: null };\n                                    break;\n                                } else {\n                                    input = yield value;\n                                }\n                            } catch (error) {\n                                result = { value: void 0, error } as Result;\n                                break;\n                            }\n                        }\n\n                        for (let i = callbacks.length - 1; i >= 0; i--) {\n                            callbacks[i]?.();\n                        }\n\n                        if (result.error) {\n                            throw result.error;\n                        } else {\n                            return result.value;\n                        }\n                    })() as Generator<unknown, R, unknown>;\n\n                    return gen as R;\n                } else if (typeof returns?.then === \"function\") {\n                    return Promise.resolve(returns as PromiseLike<R>).then(value => ({\n                        value,\n                        error: null,\n                    } as Result)).catch((error: unknown) => ({\n                        value: void 0,\n                        error,\n                    } as Result)).then(async result => {\n                        for (let i = callbacks.length - 1; i >= 0; i--) {\n                            await (callbacks[i] as () => void | Promise<void>)?.();\n                        }\n\n                        if (result.error) {\n                            throw result.error;\n                        } else {\n                            return result.value;\n                        }\n                    }) as R;\n                } else {\n                    result = { value: returns, error: null } as Result;\n                }\n            } catch (error) {\n                result = { value: void 0, error } as Result;\n            }\n\n            for (let i = callbacks.length - 1; i >= 0; i--) {\n                callbacks[i]?.();\n            }\n\n            if (result.error) {\n                throw result.error;\n            } else {\n                return result.value as R;\n            }\n        };\n    },\n    wrap<T, Fn extends (this: T, ...args: any[]) => any>(\n        fn: Fn,\n        wrapper: (this: T, fn: Fn, ...args: Parameters<Fn>) => ReturnType<Fn>\n    ): Fn {\n        const wrapped = function (this: any, ...args: Parameters<Fn>): ReturnType<Fn> {\n            return wrapper.call(this, fn, ...args);\n        };\n\n        Object.defineProperty(wrapped,\n            \"name\",\n            Object.getOwnPropertyDescriptor(fn, \"name\") as PropertyDescriptor);\n        Object.defineProperty(wrapped,\n            \"length\",\n            Object.getOwnPropertyDescriptor(fn, \"length\") as PropertyDescriptor);\n        Object.defineProperty(wrapped, \"toString\", {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: fn.toString.bind(fn),\n        });\n\n        return wrapped as Fn;\n    },\n    throttle(handler, options) {\n        const key = typeof options === \"number\" ? null : options.for;\n        const duration = typeof options === \"number\" ? options : options.duration;\n\n        const handleCall = function (\n            this: any,\n            cache: ThrottleCache,\n            ...args: any[]\n        ) {\n            if (cache.result && Date.now() < (cache.expires ?? 0)) {\n                if (cache.result.error) {\n                    throw cache.result.error;\n                } else {\n                    return cache.result.value;\n                }\n            }\n\n            try {\n                const returns = handler.call(this, ...args);\n                cache.result = { value: returns };\n                cache.expires = Date.now() + duration;\n                return returns;\n            } catch (error) {\n                cache.result = { error };\n                cache.expires = Date.now() + duration;\n                throw error;\n            }\n        };\n\n        if (!key) {\n            const cache: ThrottleCache = { for: null };\n            return function (this: any, ...args: any[]) {\n                return handleCall.call(this, cache, ...args);\n            };\n        } else {\n            let cache = throttleCaches.get(key);\n\n            if (!cache) {\n                cache = { for: key };\n                throttleCaches.set(key, cache);\n            }\n\n            return function (this: any, ...args: any[]) {\n                return handleCall.call(this, cache as ThrottleCache, ...args);\n            };\n        }\n    },\n    mixins(base, ...mixins) {\n        const obj = { ctor: null as any as Constructor<any> };\n        obj.ctor = class extends (<any>base) { }; // make sure this class has no name\n\n        for (const mixin of mixins) {\n            if (typeof mixin == \"function\") {\n                mergeHierarchy(obj.ctor, mixin);\n            } else if (mixin && typeof mixin == \"object\") {\n                mergeIfNotExists(obj.ctor.prototype, mixin);\n            } else {\n                throw new TypeError(\"mixin must be a constructor or an object\");\n            }\n        }\n\n        return obj.ctor as Constructor<any>;\n    },\n    isSubclassOf(ctor1, ctor2) {\n        return typeof ctor1 === \"function\"\n            && typeof ctor2 === \"function\"\n            && ctor1.prototype instanceof ctor2;\n    },\n    read<T>(source: any, eventMap: {\n        event?: string; // for EventSource custom event\n        message?: string;\n        data?: string;\n        error?: string;\n        close?: string;\n    } | undefined = undefined): AsyncIterable<T> {\n        if (typeof source[Symbol.asyncIterator] === \"function\") {\n            return source;\n        }\n\n        const iterable = {\n            ended: false,\n            error: null as Error | null,\n            queue: [] as T[],\n            consumers: [] as {\n                resolve: (data: IteratorResult<T>) => void;\n                reject: (err: any) => void;\n            }[],\n            next() {\n                return new Promise<IteratorResult<T>>((resolve, reject) => {\n                    if (this.error && !this.ended) {\n                        // If there is error occurred during the last transmission and the iterator\n                        // hasn't been closed, reject that error and stop the iterator immediately.\n                        reject(this.error);\n                        this.ended = true;\n                    } else if (this.ended && !this.queue.length) {\n                        // If the iterator has is closed, resolve the pending consumer with void\n                        // value.\n                        resolve({ value: void 0 as T, done: true });\n                    } else if (this.queue.length > 0) {\n                        // If there are data in the queue, resolve the the first piece immediately.\n                        resolve({ value: this.queue.shift() as T, done: false });\n                    } else {\n                        // If there are no queued data, push the consumer to a waiting queue.\n                        this.consumers.push({ resolve, reject });\n                    }\n                });\n            }\n        };\n\n        const handleMessage = (data: T) => {\n            if (iterable.consumers.length > 0) {\n                iterable.consumers.shift()?.resolve({ value: data, done: false });\n            } else {\n                iterable.queue.push(data);\n            }\n        };\n        const handleClose = () => {\n            iterable.ended = true;\n            let consumer: typeof iterable[\"consumers\"][0] | undefined;\n\n            while (consumer = iterable.consumers.shift()) {\n                consumer.resolve({ value: undefined, done: true });\n            }\n        };\n        const handleError = (err: Error) => {\n            iterable.error = err;\n\n            if (iterable.consumers.length > 0) {\n                iterable.consumers.forEach(item => {\n                    item.reject(err);\n                });\n                iterable.consumers = [];\n            }\n        };\n        const handleBrowserErrorEvent = (ev: Event) => {\n            let err: Error;\n\n            if (ev instanceof ErrorEvent) {\n                err = ev.error || new Error(ev.message);\n            } else {\n                // @ts-ignore\n                err = new Error(\"something went wrong\", { cause: ev });\n            }\n\n            handleError(err);\n        };\n\n        const proto = Object.getPrototypeOf(source);\n        const msgDesc = Object.getOwnPropertyDescriptor(proto, \"onmessage\");\n\n        if (msgDesc?.set && typeof source.close === \"function\") { // WebSocket or EventSource\n            const errDesc = Object.getOwnPropertyDescriptor(proto, \"onerror\");\n            const closeDesc = Object.getOwnPropertyDescriptor(proto, \"onclose\");\n            let cleanup: () => void;\n\n            if (eventMap?.event &&\n                eventMap?.event !== \"message\" &&\n                typeof source[\"addEventListener\"] === \"function\"\n            ) { // for EventSource listening on custom events\n                const es = source as EventSource;\n                const eventName = eventMap.event;\n                const msgListener = (ev: MessageEvent<T>) => {\n                    handleMessage(ev.data);\n                };\n\n                es.addEventListener(eventName, msgListener);\n                cleanup = () => {\n                    es.removeEventListener(eventName, msgListener);\n                };\n            } else {\n                msgDesc.set.call(source, (ev: MessageEvent<T>) => {\n                    handleMessage(ev.data);\n                });\n                cleanup = () => {\n                    msgDesc.set?.call(source, null);\n                };\n            }\n\n            errDesc?.set?.call(source, handleBrowserErrorEvent);\n\n            if (closeDesc?.set) { // WebSocket\n                closeDesc.set.call(source, () => {\n                    handleClose();\n                    closeDesc.set?.call(source, null);\n                    errDesc?.set?.call(source, null);\n                    cleanup?.();\n                });\n            } else if (!closeDesc?.set && typeof source.close === \"function\") { // EventSource\n                // EventSource by default does not trigger close event, we need to make sure when\n                // it calls the close() function, the iterator is automatically closed.\n                const es = source as EventSource;\n                const _close = es.close;\n                es.close = function close() {\n                    _close.call(es);\n                    handleClose();\n                    es.close = _close;\n                    errDesc?.set?.call(source, null);\n                    cleanup?.();\n                };\n            }\n        } else if (typeof source.send === \"function\" && typeof source.close === \"function\") {\n            // non-standard WebSocket implementation\n            const ws = source as WebSocket;\n            ws.onmessage = (ev: MessageEvent<T>) => {\n                handleMessage(ev.data);\n            };\n            ws.onerror = handleBrowserErrorEvent;\n            ws.onclose = () => {\n                handleClose();\n                ws.onclose = null;\n                ws.onerror = null;\n                ws.onmessage = null;\n            };\n        } else if (typeof source[\"addEventListener\"] === \"function\") { // EventTarget\n            const target = source as EventTarget;\n            const msgEvent = eventMap?.message || \"message\";\n            const errEvent = eventMap?.error || \"error\";\n            const closeEvent = eventMap?.close || \"close\";\n            const msgListener = (ev: Event) => {\n                if (ev instanceof MessageEvent) {\n                    handleMessage(ev.data);\n                }\n            };\n\n            target.addEventListener(msgEvent, msgListener);\n            target.addEventListener(errEvent, handleBrowserErrorEvent);\n            target.addEventListener(closeEvent, function closeListener() {\n                handleClose();\n                target.removeEventListener(closeEvent, closeListener);\n                target.removeEventListener(msgEvent, msgListener);\n                target.removeEventListener(errEvent, handleBrowserErrorEvent);\n            });\n        } else if (typeof source[\"on\"] === \"function\") { // EventEmitter\n            const target = source as NodeJS.EventEmitter;\n            const dataEvent = eventMap?.data || \"data\";\n            const errEvent = eventMap?.error || \"error\";\n            const endEvent = eventMap?.close || \"close\";\n\n            target.on(dataEvent, handleMessage);\n            target.once(errEvent, handleError);\n            target.once(endEvent, () => {\n                handleClose();\n                target.off(dataEvent, handleMessage);\n                target.off(dataEvent, handleError);\n            });\n        } else {\n            throw new TypeError(\"the input source cannot be read as an AsyncIterable object\");\n        }\n\n        return {\n            [Symbol.asyncIterator]() {\n                return iterable;\n            }\n        };\n    },\n    async run(script, args = undefined, options = undefined) {\n        const msg = {\n            type: \"ffi\",\n            script,\n            baseUrl: \"\",\n            fn: options?.fn || \"default\",\n            args: args ?? [],\n        };\n\n        if (typeof Deno === \"object\") {\n            msg.baseUrl = \"file://\" + Deno.cwd() + \"/\";\n        } else if (isNode) {\n            msg.baseUrl = \"file://\" + process.cwd() + \"/\";\n        } else if (typeof location === \"object\") {\n            msg.baseUrl = location.href;\n        }\n\n        // `buffer` is used to store data pieces yielded by generator functions before they are\n        // consumed. `error` and `result` serves similar purposes for function results.\n        const buffer: any[] = [];\n        let error: Error | null = null;\n        let result: { value: any; } | undefined;\n        let resolver: {\n            resolve: (data: any) => void;\n            reject: (err: unknown) => void;\n        } | undefined;\n        let iterator: NodeJS.EventEmitter | undefined;\n        let workerId: number | undefined;\n        let poolRecord: typeof workerPool[0] | undefined;\n        let release: () => void;\n        let terminate = () => Promise.resolve<void>(void 0);\n        const timeout = options?.timeout ? setTimeout(() => {\n            const err = new Error(`operation timeout after ${options.timeout}ms`);\n\n            if (resolver) {\n                resolver.reject(err);\n            } else {\n                error = err;\n            }\n\n            terminate();\n        }, options.timeout) : null;\n\n        const handleMessage = (msg: any) => {\n            if (msg && typeof msg === \"object\" && typeof msg.type === \"string\") {\n                if (msg.type === \"error\") {\n                    return handleError(msg.error);\n                } else if (msg.type === \"return\") {\n                    if (options?.keepAlive) {\n                        // Release before resolve.\n                        release?.();\n\n                        if (workerConsumerQueue.length) {\n                            // Queued consumer now has chance to gain the worker.\n                            workerConsumerQueue.shift()?.();\n                        }\n                    } else {\n                        terminate();\n                    }\n\n                    if (resolver) {\n                        resolver.resolve(msg.value);\n                    } else {\n                        result = { value: msg.value };\n                    }\n                } else if (msg.type === \"yield\") {\n                    if (msg.done) {\n                        // The final message of yield event is the return value.\n                        handleMessage({ type: \"return\", value: msg.value });\n                    } else {\n                        if (iterator) {\n                            iterator.emit(\"data\", msg.value);\n                        } else {\n                            buffer.push(msg.value);\n                        }\n                    }\n                }\n            }\n        };\n\n        const handleError = (err: Error | null) => {\n            if (resolver) {\n                resolver.reject(err);\n            } else if (iterator) {\n                iterator.emit(\"error\", err);\n            } else {\n                error = err;\n            }\n        };\n        const handleExit = () => {\n            if (poolRecord) {\n                // Clean the pool before resolve.\n                workerPool = workerPool.filter(record => record !== poolRecord);\n\n                if (workerConsumerQueue.length) {\n                    // Queued consumer now has chance to create new worker.\n                    workerConsumerQueue.shift()?.();\n                }\n            }\n\n            if (resolver) {\n                resolver.resolve(void 0);\n            } else if (iterator) {\n                iterator.emit(\"close\");\n            } else if (!error && !result) {\n                result = { value: void 0 };\n            }\n        };\n\n        if (isNode) {\n            const path = await import(\"path\");\n            const { fileURLToPath } = await import(\"url\");\n            let _filename: string;\n            let _dirname: string;\n            let entry: string;\n\n            if (typeof __filename === \"string\") {\n                _filename = __filename;\n                _dirname = __dirname;\n            } else {\n                // This file URL will be replace with `import.meta.url` by Rollup plugin.\n                _filename = fileURLToPath(\"file://{__filename}\");\n                _dirname = path.dirname(_filename);\n            }\n\n            if ([\"cjs\", \"esm\"].includes(path.basename(_dirname))) { // compiled\n                entry = path.join(path.dirname(_dirname), \"worker.mjs\");\n            } else {\n                entry = path.join(_dirname, \"worker.mjs\");\n            }\n\n            if (options?.adapter === \"child_process\") {\n                let worker: ChildProcess;\n                let ok = true;\n                poolRecord = workerPool.find(item => {\n                    return item.adapter === \"child_process\" && !item.busy;\n                });\n\n                if (poolRecord) {\n                    worker = poolRecord.worker as ChildProcess;\n                    workerId = poolRecord.workerId;\n                    poolRecord.busy = true;\n                } else if (workerPool.length < maxWorkerNum) {\n                    const { fork } = await import(\"child_process\");\n                    const isPrior14 = parseInt(process.version.slice(1)) < 14;\n                    worker = fork(entry, {\n                        stdio: \"inherit\",\n                        serialization: isPrior14 ? \"advanced\" : \"json\",\n                    });\n                    workerId = worker.pid as number;\n                    ok = await new Promise<boolean>((resolve) => {\n                        worker.once(\"exit\", () => {\n                            if (error) {\n                                // The child process took too long to start and cause timeout error.\n                                resolve(false);\n                            }\n                        });\n                        worker.once(\"message\", () => {\n                            worker.removeAllListeners(\"exit\");\n                            resolve(true);\n                        });\n                    });\n\n                    // Fill the worker pool regardless the current call should keep-alive or not,\n                    // this will make sure that the total number of workers will not exceed the\n                    // maxWorkerNum. If the the call doesn't keep-alive the worker, it will be\n                    // cleaned after the call.\n                    ok && workerPool.push(poolRecord = {\n                        workerId,\n                        worker,\n                        adapter: \"child_process\",\n                        busy: true,\n                    });\n                } else {\n                    // Put the current call in the consumer queue if there are no workers available,\n                    // once an existing call finishes, the queue will pop the its head consumer and\n                    // retry.\n                    return new Promise<void>((resolve) => {\n                        workerConsumerQueue.push(resolve);\n                    }).then(() => jsext.run(script, args, options));\n                }\n\n                release = () => {\n                    // Remove the event listener so that later calls will not mess up.\n                    worker.off(\"message\", handleMessage);\n                    poolRecord && (poolRecord.busy = false);\n                };\n                terminate = () => Promise.resolve(void worker.kill(1));\n\n                if (ok) {\n                    worker.send(msg);\n                    worker.on(\"message\", handleMessage);\n                    worker.once(\"error\", handleError);\n                    worker.once(\"exit\", handleExit);\n                }\n            } else {\n                let worker: NodeWorker;\n                let ok = true;\n                poolRecord = workerPool.find(item => {\n                    return item.adapter === \"worker_threads\" && !item.busy;\n                });\n\n                if (poolRecord) {\n                    worker = poolRecord.worker as NodeWorker;\n                    workerId = poolRecord.workerId;\n                    poolRecord.busy = true;\n                } else if (workerPool.length < maxWorkerNum) {\n                    const { Worker } = await import(\"worker_threads\");\n                    worker = new Worker(entry);\n                    // `threadId` may not exist in Bun.\n                    workerId = worker.threadId ?? workerIdCounter.next().value;\n                    ok = await new Promise<boolean>((resolve) => {\n                        worker.once(\"exit\", () => {\n                            if (error) {\n                                // The child process took too long to start and cause timeout error.\n                                resolve(false);\n                            }\n                        });\n                        worker.once(\"online\", () => {\n                            worker.removeAllListeners(\"exit\");\n                            resolve(true);\n                        });\n                    });\n                    ok && workerPool.push(poolRecord = {\n                        workerId,\n                        worker,\n                        adapter: \"worker_threads\",\n                        busy: true,\n                    });\n                } else {\n                    return new Promise<void>((resolve) => {\n                        workerConsumerQueue.push(resolve);\n                    }).then(() => jsext.run(script, args, options));\n                }\n\n                release = () => {\n                    worker.off(\"message\", handleMessage);\n                    poolRecord && (poolRecord.busy = false);\n                };\n                terminate = async () => void (await worker.terminate());\n\n                if (ok) {\n                    worker.postMessage(msg);\n                    worker.on(\"message\", handleMessage);\n                    worker.once(\"error\", handleError);\n                    worker.once(\"messageerror\", handleError);\n                    worker.once(\"exit\", handleExit);\n                }\n            }\n        } else {\n            let worker: Worker;\n            poolRecord = workerPool.find(item => {\n                return item.adapter === \"worker_threads\" && !item.busy;\n            });\n\n            if (poolRecord) {\n                worker = poolRecord.worker as Worker;\n                workerId = poolRecord.workerId;\n                poolRecord.busy = true;\n            } else if (workerPool.length < maxWorkerNum) {\n                let url: string;\n\n                if (typeof Deno === \"object\") {\n                    // Deno can load the module regardless of MINE type.\n                    url = [\n                        ...(\"file://{__filename}\".split(\"/\").slice(0, -1)),\n                        \"worker-web.mjs\"\n                    ].join(\"/\");\n                } else {\n                    const _url = options?.webWorkerEntry\n                        || \"https://raw.githubusercontent.com/ayonli/jsext/main/esm/worker-web.mjs\";\n                    const res = await fetch(_url);\n                    let blob: Blob;\n\n                    if (res.headers.get(\"content-type\")?.startsWith(\"application/javascript\")) {\n                        blob = await res.blob();\n                    } else {\n                        const buf = await res.arrayBuffer();\n                        blob = new Blob([new Uint8Array(buf)], {\n                            type: \"application/javascript\",\n                        });\n                    }\n\n                    url = URL.createObjectURL(blob);\n                }\n\n                worker = new Worker(url, { type: \"module\" });\n                workerId = workerIdCounter.next().value as number;\n                workerPool.push(poolRecord = {\n                    workerId,\n                    worker,\n                    adapter: \"worker_threads\",\n                    busy: true,\n                });\n            } else {\n                return new Promise<void>((resolve) => {\n                    workerConsumerQueue.push(resolve);\n                }).then(() => jsext.run(script, args, options));\n            }\n\n            release = () => {\n                worker.onmessage = null;\n                poolRecord && (poolRecord.busy = false);\n            };\n            terminate = async () => {\n                await Promise.resolve(worker.terminate());\n                handleExit();\n            };\n\n            worker.postMessage(msg);\n            worker.onmessage = (ev) => handleMessage(ev.data);\n            worker.onerror = (ev) => handleMessage(ev.error || new Error(ev.message));\n            worker.onmessageerror = () => {\n                handleError(new Error(\"unable to deserialize the message\"));\n            };\n        }\n\n        return {\n            workerId,\n            async abort() {\n                timeout && clearTimeout(timeout);\n                await terminate();\n            },\n            async result() {\n                return await new Promise<any>((resolve, reject) => {\n                    if (error) {\n                        reject(error);\n                    } else if (result) {\n                        resolve(result.value);\n                    } else {\n                        resolver = { resolve, reject };\n                    }\n                });\n            },\n            async *iterate() {\n                if (resolver) {\n                    throw new Error(\"result() has been called\");\n                } else if (result) {\n                    throw new TypeError(\"the response is not iterable\");\n                }\n\n                const { EventEmitter } = await import(\"events\");\n                iterator = new EventEmitter();\n\n                if (buffer.length) {\n                    (async () => {\n                        await Promise.resolve(null);\n                        let msg: any;\n\n                        while (msg = buffer.shift()) {\n                            iterator.emit(\"data\", msg);\n                        }\n                    })().catch(console.error);\n                }\n\n                for await (const msg of jsext.read<any>(iterator)) {\n                    yield msg;\n                }\n            },\n        };\n    }\n};\n\nexport default jsext;\n","import { avg, product, sum } from \".\";\n\ndeclare global {\n    interface Math {\n        /** Returns the sum value of the given values. */\n        sum(...values: number[]): number;\n        /** Returns the average value of the given values. */\n        avg(...values: number[]): number;\n        /** Returns a the product value multiplied by the given values. */\n        product(...values: number[]): number;\n    }\n}\n\nMath.sum = sum;\nMath.avg = avg;\nMath.product = product;\n","/** Returns the sum value of the given values. */\nexport function sum(...values: number[]): number {\n    return values.reduce((sum, value) => sum + value, 0);\n};\n\n/** Returns the average value of the given values. */\nexport function avg(...values: number[]): number {\n    return Math.sum(...values) / values.length;\n};\n\n/** Returns a the product value multiplied by the given values. */\nexport function product(...values: number[]): number {\n    return values.slice(1).reduce((sum, value) => sum * value, values[0] ?? 0);\n};\n","import { isBetween, isFloat, isNumeric, random, sequence } from \".\";\n\ndeclare global {\n    interface NumberConstructor {\n        /** Returns true if the given value is a float, false otherwise. */\n        isFloat(value: unknown): boolean;\n        /**\n         * Returns `true` if the given value is a numeric value, `false` otherwise. A numeric value\n         * is a number, a bigint, or a string that can be converted as a number or bigint.\n         */\n        isNumeric(value: unknown): boolean;\n        /** Return `true` if a number is between the given range (inclusive). */\n        isBetween(value: number, [min, max]: [number, number]): boolean;\n        /** Returns a random integer ranged from `min` to `max` (inclusive). */\n        random(min: number, max: number): number;\n        /** Creates a generator that produces sequential numbers from `min` to `max` (inclusive). */\n        sequence(min: number, max: number, step?: number, loop?: boolean): Generator<number, void, unknown>;\n    }\n}\n\nNumber.isFloat = isFloat;\nNumber.isNumeric = isNumeric;\nNumber.isBetween = isBetween;\nNumber.random = random;\nNumber.sequence = sequence;\n","/** Returns `true` if the given value is a float number, `false` otherwise. */\nexport function isFloat(value: unknown): boolean {\n    return typeof value === \"number\"\n        && !Number.isNaN(value)\n        && (!Number.isFinite(value) || (value as number) % 1 !== 0);\n}\n\n/**\n * Returns `true` if the given value is a numeric value, `false` otherwise. A numeric value is a \n * number, a bigint, or a string that can be converted to a number or bigint.\n */\nexport function isNumeric(value: unknown): boolean {\n    const type = typeof value;\n\n    if (type === \"number\" || type === \"bigint\") {\n        return true;\n    } else if (type === \"string\") {\n        if (!Number.isNaN(value)) {\n            return true;\n        } else {\n            try {\n                BigInt(value as string);\n                return true;\n            } catch {\n                return false;\n            }\n        }\n    }\n\n    return false;\n}\n\n/** Return `true` if a number is between the given range (inclusive). */\nexport function isBetween(value: number, [min, max]: [number, number]): boolean {\n    return value >= min && value <= max;\n}\n\n/** Returns a random integer ranged from `min` to `max`. */\nexport function random(min: number, max: number): number {\n    return min + Math.floor(Math.random() * (max - min + 1));\n}\n\n/** Creates a generator that produces sequential numbers from `min` to `max` (inclusive). */\nexport function* sequence(min: number, max: number, step = 1, loop = false) {\n    let id = min;\n\n    while (true) {\n        yield id;\n\n        if (id >= max) {\n            if (loop) {\n                id = min;\n            } else {\n                break;\n            }\n        } else {\n            id += step;\n        }\n    }\n}\n","import { hasOwn, hasOwnMethod, omit, patch, pick, as } from \".\";\n\ndeclare global {\n    interface ObjectConstructor {\n        hasOwn(obj: any, key: string | number | symbol): boolean;\n        /**\n         * Returns `true` if the specified object has the indicated method as its own method (in its\n         * own prototype). If the method is inherited, or is not in the prototype, or does not exist,\n         * this function returns `false`.\n         */\n        hasOwnMethod(obj: any, method: string | symbol): boolean;\n        /**\n         * Copies the key-value pairs that are presented in the source objects but are missing in\n         * the target object into the target, later pairs are skipped if the same key already exists.\n         * \n         * This function mutates the target object and returns it.\n         */\n        patch<T extends {}, U>(target: T, source: U): T & U;\n        patch<T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V;\n        patch<T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\n        patch(target: object, ...sources: any[]): any;\n        /** Creates an object composed of the picked keys. */\n        pick<T extends object, U extends keyof T>(obj: T, keys: U[]): Pick<T, U>;\n        pick<T>(obj: T, keys: (string | symbol)[]): Partial<T>;\n        /**\n         * Creates an object composed without the picked keys.\n         * \n         * NOTE: this function only collect keys from the object's own properties, except for type\n         * Error, whose `name`, `message` and `cause` are always collected.\n         */\n        omit<T extends object, U extends keyof T>(obj: T, keys: U[]): Omit<T, U>;\n        omit<T>(obj: T, keys: (string | symbol)[]): Partial<T>;\n        /**\n         * Returns the object if it's an instance of the given type, otherwise returns `null`.\n         * This function is mainly used for the optional chaining syntax.\n         * @example\n         *  Object.as(bar, SomeType)?.doSomething();\n         */\n        as(obj: any, type: StringConstructor): string | null;\n        as(obj: any, type: NumberConstructor): number | null;\n        as(obj: any, type: BigIntConstructor): bigint | null;\n        as(obj: any, type: BooleanConstructor): boolean | null;\n        as(obj: any, type: SymbolConstructor): symbol | null;\n        as<T>(obj: any, type: Constructor<T>): T | null;\n    }\n}\n\nif (!Object.hasOwn) {\n    Object.hasOwn = hasOwn;\n}\n\nif (!Object.hasOwnMethod) {\n    Object.hasOwnMethod = hasOwnMethod;\n}\n\nObject.patch = patch;\nObject.pick = pick;\nObject.omit = omit;\nObject.as = as;\n","import type { Constructor } from \"../index\";\n\nexport function hasOwn(obj: any, key: string | number | symbol): boolean {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\n/**\n * Returns `true` if the specified object has the indicated method as its own method (in its own\n * prototype). If the method is inherited, or is not in the prototype, or does not exist, this\n * function returns `false`.\n */\nexport function hasOwnMethod(obj: any, method: string | symbol): boolean {\n    const proto = Object.getPrototypeOf(obj);\n\n    if (!proto || !hasOwn(proto, method)) {\n        return false;\n    }\n\n    return typeof Object.getOwnPropertyDescriptor(proto, method)?.value === \"function\";\n}\n\n/**\n * Copies the key-value pairs that are presented in the source objects but are missing in\n * the target object into the target, later pairs are skipped if the same key already exists.\n * \n * This function mutates the target object and returns it.\n */\nexport function patch<T extends {}, U>(target: T, source: U): T & U;\nexport function patch<T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V;\nexport function patch<T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function patch(target: object, ...sources: any[]): any;\nexport function patch(target: any, ...sources: any[]) {\n    for (const source of sources) {\n        for (const key of Reflect.ownKeys(source)) {\n            if (!hasOwn(target, key) || target[key] === undefined) {\n                target[key] = source[key];\n            }\n        }\n    }\n\n    return target;\n};\n\n/** Creates an object composed of the picked keys. */\nexport function pick<T extends object, U extends keyof T>(obj: T, keys: U[]): Pick<T, U>;\nexport function pick<T>(obj: T, keys: (string | symbol)[]): Partial<T>;\nexport function pick(obj: any, keys: (string | symbol)[]) {\n    return keys.reduce((result: any, key: string | symbol) => {\n        if (key in obj && obj[key] !== undefined) {\n            result[key] = obj[key];\n        }\n\n        return result;\n    }, {});\n}\n\n/**\n * Creates an object composed without the picked keys.\n * \n * NOTE: this function only collect keys from the object's own properties, except for type\n * Error, whose `name`, `message` and `cause` are always collected.\n */\nexport function omit<T extends object, U extends keyof T>(obj: T, keys: U[]): Omit<T, U>;\nexport function omit<T>(obj: T, keys: (string | symbol)[]): Partial<T>;\nexport function omit(obj: any, keys: (string | symbol)[]) {\n    const allKeys = Reflect.ownKeys(obj);\n    const keptKeys = allKeys.filter(key => !keys.includes(key));\n    const result = pick(obj, keptKeys);\n\n    // special treatment for Error types\n    if (obj instanceof Error) {\n        [\"name\", \"message\", \"cause\"].forEach(key => {\n            if (!keys.includes(key) &&\n                (obj as any)[key] !== undefined &&\n                !hasOwn(result, key)\n            ) {\n                result[key] = (obj as any)[key];\n            }\n        });\n    }\n\n    return result;\n}\n\n/**\n * Returns the object if it's an instance of the given type, otherwise returns `null`.\n * This function is mainly used for the optional chaining syntax.\n * @example\n *  as(bar, SomeType)?.doSomething();\n */\nexport function as(obj: any, type: StringConstructor): string | null;\nexport function as(obj: any, type: NumberConstructor): number | null;\nexport function as(obj: any, type: BigIntConstructor): bigint | null;\nexport function as(obj: any, type: BooleanConstructor): boolean | null;\nexport function as(obj: any, type: SymbolConstructor): symbol | null;\nexport function as<T>(obj: any, type: Constructor<T>): T | null;\nexport function as(obj: any, type: any): any {\n    if (typeof type !== \"function\") {\n        throw new TypeError(\"type must be a valid constructor\");\n    }\n\n    let _type: any;\n    const primitiveMap = <Record<string, Function>>{\n        \"string\": String,\n        \"number\": Number,\n        \"bigint\": BigInt,\n        \"boolean\": Boolean,\n        \"symbol\": Symbol\n    };\n\n    if (obj instanceof type) {\n        if ([String, Number, Boolean].includes(type)) {\n            return obj.valueOf(); // make sure the primitives are returned.\n        } else {\n            return obj;\n        }\n    } else if ((_type = typeof obj) && primitiveMap[_type] === type) {\n        return obj;\n    }\n\n    return null;\n}\n","import { after, sleep, timeout, until } from \".\";\n\ndeclare global {\n    interface PromiseConstructor {\n        /** Try to resolve a promise with a timeout limit. */\n        timeout<T>(value: T | Promise<T>, ms: number): Promise<T>;\n        /** Resolves a promise only after the given duration. */\n        after<T>(value: T | PromiseLike<T>, ms: number): Promise<T>;\n        /** Blocks the context for a given time. */\n        sleep(ms: number): Promise<void>;\n        /** Blocks the context until the test is passed. */\n        until(test: () => boolean | Promise<boolean>): Promise<void>;\n    }\n}\n\nPromise.timeout = timeout;\nPromise.after = after;\nPromise.sleep = sleep;\nPromise.until = until;\n","/** Try to resolve a promise with a timeout limit. */\nexport async function timeout<T>(value: T | PromiseLike<T>, ms: number): Promise<T> {\n    const result = await Promise.race([\n        value,\n        new Promise<T>((_, reject) => setTimeout(() => {\n            reject(new Error(`operation timeout after ${ms}ms`));\n        }, ms))\n    ]);\n    return result;\n}\n\n/** Resolves a promise only after the given duration. */\nexport async function after<T>(value: T | PromiseLike<T>, ms: number): Promise<T> {\n    const [result] = await Promise.allSettled([\n        value,\n        new Promise<void>(resolve => setTimeout(resolve, ms))\n    ]);\n\n    if (result.status === \"fulfilled\") {\n        return result.value;\n    } else {\n        throw result.reason;\n    }\n}\n\n/** Blocks the context for a given time. */\nexport async function sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/** Blocks the context until the test is passed. */\nexport async function until(test: () => boolean | Promise<boolean>): Promise<void> {\n    if (typeof globalThis.setImmediate === \"undefined\") {\n        // @ts-ignore\n        globalThis.setImmediate = (cb: () => void) => setTimeout(cb, 0);\n    }\n\n    do { await new Promise<void>(globalThis.setImmediate); } while ((await test()) == false);\n}\n","import {\n    compare,\n    random,\n    byteLength as _byteLength,\n    capitalize as _capitalize,\n    chunk as _chunk,\n    count as _count,\n    hyphenate as _hyphenate,\n    truncate as _truncate,\n    words as _words\n} from \".\";\n\ndeclare global {\n    interface StringConstructor {\n        /**\n         * Compares two strings, returns `-1` if `a < b`, `0` if `a == b` and `1` if `a > b`.\n         */\n        compare(str1: string, str2: string): -1 | 0 | 1;\n        /** Returns a random string, the charset matches `/[0-9a-zA-Z]/` */\n        random(length: number): string;\n    }\n\n    interface String {\n        /** Counts the occurrence of the sub-string in the string. */\n        count(sub: string): number;\n        /**\n         * Capitalizes the string, if `all` is true, all words are capitalized, otherwise only\n         * the first word will be capitalized.\n         */\n        capitalize(all?: boolean): string;\n        /** Replaces the spaces between non-empty characters of the string with hyphens (`-`). */\n        hyphenate(): string;\n        /** Extracts words (in latin characters) from the string. */\n        words(): string[];\n        /** Breaks the string into smaller chunks according to the given length. */\n        chunk(length: number): string[];\n        /** Truncates the string to the given length (including the ending `...`). */\n        truncate(length: number): string;\n        /** Returns the byte length of the string. */\n        byteLength(): number;\n    }\n}\n\nString.compare = compare;\nString.random = random;\n\nString.prototype.count = function count(sub) {\n    return _count(String(this), sub);\n};\n\nString.prototype.capitalize = function capitalize(all) {\n    return _capitalize(String(this), all);\n};\n\nString.prototype.hyphenate = function capitalize() {\n    return _hyphenate(String(this));\n};\n\nString.prototype.words = function words() {\n    return _words(String(this));\n};\n\nString.prototype.chunk = function chunk(length) {\n    return _chunk(String(this), length);\n};\n\nString.prototype.truncate = function truncate(length) {\n    return _truncate(String(this), length);\n};\n\nString.prototype.byteLength = function byteLength() {\n    return _byteLength(String(this));\n};\n","import { chunk as _chunk } from \"../array\";\n\n/**\n * Compares two strings, returns `-1` if `a < b`, `0` if `a == b` and `1` if `a > b`.\n */\nexport function compare(str1: string, str2: string): -1 | 0 | 1 {\n    if (str1 < str2) {\n        return -1;\n    } else if (str1 > str2) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/** Returns a random string, the charset matches `/[0-9a-zA-Z]/` */\nexport function random(length: number): string {\n    const chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let str = \"\";\n\n    while (0 < length--) {\n        const i = Math.floor(Math.random() * chars.length);\n        str += chars[i];\n    }\n\n    return str;\n}\n\n/** Counts the occurrence of the sub-string in the string. */\nexport function count(str: string, sub: string): number {\n    if (!sub) {\n        return str.length + 1;\n    } else if (!str) {\n        return 0;\n    }\n\n    return str.split(sub).length - 1;\n}\n\n/**\n * Capitalizes the string, if `all` is true, all words are capitalized, otherwise only\n * the first word will be capitalized.\n */\nexport function capitalize(str: string, all?: boolean): string {\n    const regex = all ? /\\w+/g : /\\w+/;\n    return str.replace(regex, (match) => {\n        return (match[0] as string).toUpperCase() + match.slice(1).toLowerCase();\n    });\n}\n\n/** Replaces the spaces between non-empty characters of the string with hyphens (`-`). */\nexport function hyphenate(str: string): string {\n    return str.replace(/(\\S)\\s+(\\S)/g, (_, $1, $2) => $1 + \"-\" + $2);\n}\n\n/** Extracts words (in latin characters) from the string. */\nexport function words(str: string): string[] {\n    const matches = str.match(/\\w+/g);\n    return matches ? [...matches] : [];\n}\n\n/** Breaks the string into smaller chunks according to the given length. */\nexport function chunk(str: string, length: number): string[] {\n    return _chunk(str, length) as string[];\n}\n\n/** Truncates the string to the given length (including the ending `...`). */\nexport function truncate(str: string, length: number): string {\n    if (length <= 0) {\n        return \"\";\n    } else if (length >= str.length) {\n        return str;\n    } else {\n        length -= 3;\n        return str.slice(0, length) + \"...\";\n    }\n}\n\nconst encoder = new TextEncoder();\n/** Returns the byte length of the string. */\nexport function byteLength(str: string): number {\n    return encoder.encode(str).byteLength;\n};\n","import { compare, equals as _equals, split as _split, chunk as _chunk } from \".\";\n\ndeclare global {\n    interface Uint8ArrayConstructor {\n        /** Like `Buffer.compare` but for pure `Uint8Array`. */\n        compare(arr1: Uint8Array, arr2: Uint8Array): -1 | 0 | 1;\n    }\n\n    interface Uint8Array {\n        /**\n         * Compare this array to another array and see if it contains the same elements as\n         * this array.\n         */\n        equals(another: Uint8Array): boolean;\n        /** Breaks the array into smaller chunks according to the given delimiter. */\n        split(delimiter: number): this[];\n        /** Breaks the array into smaller chunks according to the given length. */\n        chunk(length: number): this[];\n    }\n}\n\nUint8Array.compare = compare;\n\nUint8Array.prototype.equals = function equals(another) {\n    return _equals(this, another);\n};\n\nUint8Array.prototype.split = function split(delimiter) {\n    return _split(this, delimiter);\n};\n\nUint8Array.prototype.chunk = function chunk(length) {\n    return _chunk(this, length);\n};\n","import { equals as _equals, split as _split, chunk as _chunk } from \"../array\";\n\n/** Like `Buffer.compare` but for pure `Uint8Array`. */\nexport function compare(arr1: Uint8Array, arr2: Uint8Array): -1 | 0 | 1 {\n    if (arr1 === arr2) {\n        return 0;\n    }\n\n    for (let i = 0; i < arr1.length; i++) {\n        const ele1 = arr1[i] as number;\n        const ele2 = arr2[i];\n\n        if (ele2 === undefined) {\n            return 1;\n        } else if (ele1 < ele2) {\n            return -1;\n        } else if (ele1 > ele2) {\n            return 1;\n        }\n    }\n\n    return arr1.length < arr2.length ? -1 : 0;\n}\n\n/**\n * Compare this array to another array and see if it contains the same elements as\n * this array.\n */\nexport function equals(arr1: Uint8Array, arr2: Uint8Array): boolean {\n    if (!(arr1 instanceof Uint8Array) || !(arr2 instanceof Uint8Array)) {\n        return false;\n    }\n\n    return _equals(arr1, arr2);\n}\n\n/** Breaks the array into smaller chunks according to the given delimiter. */\nexport function split<T extends Uint8Array>(arr: T, delimiter: number): T[] {\n    return _split(arr, delimiter) as T[];\n}\n\n/** Breaks the array into smaller chunks according to the given length. */\nexport function chunk<T extends Uint8Array>(arr: T, length: number): T[] {\n    return _chunk(arr, length) as T[];\n}\n","module.exports = require(\"child_process\");","module.exports = require(\"events\");","module.exports = require(\"path\");","module.exports = require(\"url\");","module.exports = require(\"worker_threads\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(284);\n"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","this","_typeof","obj","Symbol","iterator","constructor","prototype","isIteratorLike","next","isIterableIterator","isAsyncIterableIterator","asyncIterator","hasGeneratorSpecials","Object","defineProperty","value","isIterable","isAsyncIterable","isGenerator","isAsyncGenerator","Array","first","last","length","count","ele","equals","another","split","delimiter","chunk","uniq","shuffle","toShuffled","slice","toReversed","reverse","toSorted","fn","sort","orderBy","key","order","groupBy","type","arr","i","arr1","arr2","chunks","limit","offset","push","ctor","from","size","Math","ceil","idx","Set","j","floor","random","items","a","b","isArray","_a","_b","undefined","Map","groups","item","list","get","set","inverse","BiMap","toStringTag","iterable","super","getKey","hasValue","has","deleteValue","delete","clear","internal","CiMap","id","String","toLowerCase","entries","values","keys","forEach","callbackfn","thisArg","globalThis","Exception","Error","message","options","code","cause","configurable","enumerable","writable","toObject","fromObject","toJSON","err","omit","name","create","Reflect","ownKeys","filter","includes","isNode","process","versions","node","throttleCaches","workerIdCounter","sequence","Number","MAX_SAFE_INTEGER","workerPool","workerConsumerQueue","mergeIfNotExists","proto","source","mergeSuper","props","prop","setProp","hasOwnProperty","mergeHierarchy","mixin","_super","getPrototypeOf","desc","getOwnPropertyDescriptor","jsext","args","try","apply","returns","input","result","done","Promise","resolve","then","catch","func","callbacks","defer","cb","call","gen","error","async","wrap","wrapper","wrapped","toString","bind","throttle","handler","for","duration","handleCall","cache","Date","now","expires","mixins","base","TypeError","isSubclassOf","ctor1","ctor2","read","eventMap","ended","queue","consumers","reject","shift","handleMessage","data","handleClose","consumer","handleError","handleBrowserErrorEvent","ev","ErrorEvent","msgDesc","close","errDesc","closeDesc","cleanup","event","es","eventName","msgListener","addEventListener","removeEventListener","_close","send","ws","onmessage","onerror","onclose","target","msgEvent","errEvent","closeEvent","MessageEvent","closeListener","dataEvent","endEvent","on","once","off","run","script","msg","baseUrl","Deno","cwd","location","href","buffer","resolver","workerId","poolRecord","release","terminate","timeout","setTimeout","keepAlive","emit","handleExit","record","path","fileURLToPath","_filename","_dirname","entry","__filename","__dirname","basename","join","dirname","adapter","worker","ok","find","busy","fork","isPrior14","parseInt","version","stdio","serialization","pid","removeAllListeners","kill","Worker","threadId","postMessage","url","_url","webWorkerEntry","res","fetch","blob","headers","startsWith","buf","arrayBuffer","Blob","Uint8Array","URL","createObjectURL","onmessageerror","abort","clearTimeout","iterate","EventEmitter","console","sum","avg","product","reduce","isFloat","isNumeric","isBetween","isNaN","isFinite","BigInt","min","max","step","loop","hasOwn","hasOwnMethod","patch","pick","as","method","sources","keptKeys","_type","primitiveMap","Boolean","valueOf","after","sleep","until","ms","race","_","allSettled","status","reason","test","setImmediate","compare","sub","capitalize","all","hyphenate","words","truncate","byteLength","str1","str2","chars","str","regex","replace","match","toUpperCase","$1","$2","matches","encoder","TextEncoder","encode","ele1","ele2","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}
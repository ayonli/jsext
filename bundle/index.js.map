{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@ayonli/jsext/webpack/universalModuleDefinition","webpack://@ayonli/jsext/./node_modules/check-iterable/index.js","webpack://@ayonli/jsext/./src/array/augment.ts","webpack://@ayonli/jsext/./src/array/index.ts","webpack://@ayonli/jsext/./src/collections/BiMap.ts","webpack://@ayonli/jsext/./src/collections/CiMap.ts","webpack://@ayonli/jsext/./src/collections/augment.ts","webpack://@ayonli/jsext/./src/collections/index.ts","webpack://@ayonli/jsext/./src/error/Exception.ts","webpack://@ayonli/jsext/./src/error/augment.ts","webpack://@ayonli/jsext/./src/error/index.ts","webpack://@ayonli/jsext/./src/index.ts","webpack://@ayonli/jsext/./src/math/augment.ts","webpack://@ayonli/jsext/./src/math/index.ts","webpack://@ayonli/jsext/./src/number/augment.ts","webpack://@ayonli/jsext/./src/number/index.ts","webpack://@ayonli/jsext/./src/object/augment.ts","webpack://@ayonli/jsext/./src/object/index.ts","webpack://@ayonli/jsext/./src/promise/augment.ts","webpack://@ayonli/jsext/./src/promise/index.ts","webpack://@ayonli/jsext/./src/string/augment.ts","webpack://@ayonli/jsext/./src/string/index.ts","webpack://@ayonli/jsext/./src/uint8array/augment.ts","webpack://@ayonli/jsext/./src/uint8array/index.ts","webpack://@ayonli/jsext/external node-commonjs \"child_process\"","webpack://@ayonli/jsext/external node-commonjs \"events\"","webpack://@ayonli/jsext/external node-commonjs \"fs\"","webpack://@ayonli/jsext/external node-commonjs \"os\"","webpack://@ayonli/jsext/external node-commonjs \"path\"","webpack://@ayonli/jsext/external node-commonjs \"util\"","webpack://@ayonli/jsext/external node-commonjs \"worker_threads\"","webpack://@ayonli/jsext/webpack/bootstrap","webpack://@ayonli/jsext/./src/augment.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@ayonli/jsext\"] = factory();\n\telse\n\t\troot[\"@ayonli/jsext\"] = factory();\n})(this, () => {\nreturn ","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isIterable = isIterable;\nexports.isAsyncIterable = isAsyncIterable;\nexports.isIteratorLike = isIteratorLike;\nexports.isIterableIterator = isIterableIterator;\nexports.isAsyncIterableIterator = isAsyncIterableIterator;\nexports.isGenerator = isGenerator;\nexports.isAsyncGenerator = isAsyncGenerator;\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nif (!Symbol.asyncIterator) {\n  Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\");\n}\n\n/**\n * Checks if the given object is an Iterable (implemented `@@iterator`).\n * @returns {obj is Iterable<any>}\n */\nfunction isIterable(obj) {\n  return obj !== null && obj !== undefined && typeof obj[Symbol.iterator] === \"function\";\n}\n\n/**\n * Checks if the given object is an AsyncIterable (implemented `@@asyncIterator`).\n * @returns {obj is AsyncIterable<any>}\n */\nfunction isAsyncIterable(obj) {\n  return obj !== null && obj !== undefined && typeof obj[Symbol.asyncIterator] === \"function\";\n}\n\n/**\n * Checks if the given object is an IteratorLike (implemented `next`).\n * @returns {obj is { next: Function }}\n */\nfunction isIteratorLike(obj) {\n  // An iterable object has a 'next' method, however including a 'next' method\n  // doesn't ensure the object is an iterator, it is only iterator-like.\n  return _typeof(obj) === \"object\" && obj !== null && typeof obj.next === \"function\";\n}\n\n/**\n * Checks if the given object is an IterableIterator (implemented both\n * `@@iterator` and `next`).\n */\nfunction isIterableIterator(obj) {\n  return isIteratorLike(obj) && typeof obj[Symbol.iterator] === \"function\";\n}\n\n/**\n * Checks if the given object is an AsyncIterableIterator (implemented\n * both `@@asyncIterator` and `next`).\n * @returns {obj is AsyncIterableIterator<any>}\n */\nfunction isAsyncIterableIterator(obj) {\n  return isIteratorLike(obj) && typeof obj[Symbol.asyncIterator] === \"function\";\n}\n\n/**\n * Checks if the given object is a Generator.\n * @returns {obj is Generator}\n */\nfunction isGenerator(obj) {\n  return isIterableIterator(obj) && hasGeneratorSpecials(obj);\n}\n\n/**\n * Checks if the given object is an AsyncGenerator.\n * @returns {obj is AsyncGenerator}\n */\nfunction isAsyncGenerator(obj) {\n  return isAsyncIterableIterator(obj) && hasGeneratorSpecials(obj);\n}\nfunction hasGeneratorSpecials(obj) {\n  return typeof obj[\"return\"] === \"function\" && typeof obj[\"throw\"] === \"function\";\n}\n","import {\n    chunk as _chunk,\n    count as _count,\n    equals as _equals,\n    groupBy as _groupBy,\n    orderBy as _orderBy,\n    shuffle as _shuffle,\n    split as _split,\n    uniq as _uniq\n} from \".\";\n\ndeclare global {\n    interface Array<T> {\n        /** Returns the first element of the array, or `undefined` if the array is empty. */\n        first(): T;\n        /** Returns the last element of the array, or `undefined` is the array is empty. */\n        last(): T;\n        /** Counts the occurrence of the element in the array. */\n        count(ele: T): number;\n        /**\n         * Performs a shallow compare to another array and see if it contains the same elements as\n         * this array.\n         */\n        equals(another: T[]): boolean;\n        /** Breaks the array into smaller chunks according to the given delimiter. */\n        split(delimiter: T): T[][];\n        /** Breaks the array into smaller chunks according to the given length. */\n        chunk(length: number): T[][];\n        /** Returns a subset of the array that contains only unique items. */\n        uniq(): T[];\n        /**\n         * Reorganizes the elements in the array in random order.\n         * \n         * This function mutates the array.\n         */\n        shuffle(): T[];\n        toShuffled(): T[];\n        toReversed(): T[];\n        toSorted(fn?: ((a: T, b: T) => number) | undefined): T[];\n        /**\n         * Orders the items of the array according to the specified comparable `key` (whose value\n         * must either be a numeric or string).\n         */\n        orderBy(key: keyof T, order?: \"asc\" | \"desc\"): T[];\n        /**\n         * Groups the items of the array according to the comparable values returned by a provided\n         * callback function.\n         * The returned record / map has separate properties for each group, containing arrays with\n         * the items in the group.\n         */\n        groupBy(fn: (item: T, i: number) => string | symbol, type?: ObjectConstructor): Record<string | symbol, T[]>;\n        groupBy<K>(fn: (item: T, i: number) => K, type: MapConstructor): Map<K, T[]>;\n    }\n}\n\nArray.prototype.first = function first() {\n    return this[0];\n};\n\nArray.prototype.last = function last() {\n    return this[this.length - 1];\n};\n\nArray.prototype.count = function count(ele) {\n    return _count(this, ele);\n};\n\nArray.prototype.equals = function equals(another) {\n    return _equals(this, another);\n};\n\nArray.prototype.split = function split(delimiter) {\n    return _split(this, delimiter) as any[];\n};\n\nArray.prototype.chunk = function chunk(length) {\n    return _chunk(this, length) as any[];\n};\n\nArray.prototype.uniq = function uniq() {\n    return _uniq(this);\n};\n\nArray.prototype.shuffle = function shuffle() {\n    return _shuffle(this);\n};\n\nArray.prototype.toShuffled = function toShuffled() {\n    return this.slice().shuffle();\n};\n\nif (!Array.prototype.toReversed) {\n    Array.prototype.toReversed = function toReversed() {\n        return this.slice().reverse();\n    };\n}\n\nif (!Array.prototype.toSorted) {\n    Array.prototype.toSorted = function toSorted(fn) {\n        return this.slice().sort(fn);\n    };\n}\n\nArray.prototype.orderBy = function orderBy(key, order = \"asc\") {\n    return _orderBy(this, key, order);\n};\n\nArray.prototype.groupBy = function orderBy(\n    fn: (item: any, i: number) => any,\n    type: ObjectConstructor | MapConstructor = Object\n): any {\n    return _groupBy(this, fn, type as any);\n};\n","export interface RealArrayLike<T> extends ArrayLike<T> {\n    slice(start?: number, end?: number): RealArrayLike<T>;\n}\n\n/** Counts the occurrence of the element in the array. */\nexport function count<T>(arr: RealArrayLike<T>, ele: T): number {\n    let count = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === ele) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n/**\n * Performs a shallow compare to another array and see if it contains the same elements as\n * this array.\n */\nexport function equals<T>(arr1: RealArrayLike<T>, arr2: RealArrayLike<T>): boolean {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/** Breaks the array into smaller chunks according to the given delimiter. */\nexport function split<T>(arr: RealArrayLike<T>, delimiter: T): RealArrayLike<T>[] {\n    const chunks: (typeof arr)[] = [];\n    const limit = arr.length;\n    let offset = 0;\n\n    for (let i = 0; i < limit; i++) {\n        if (arr[i] === delimiter) {\n            chunks.push(arr.slice(offset, i));\n            offset = i + 1;\n        }\n    }\n\n    if (offset < limit) {\n        chunks.push(arr.slice(offset, limit));\n    } else if (offset === limit) {\n        const ctor = arr.constructor as (new (...args: any[]) => RealArrayLike<T>) & {\n            from?: (iterable: Iterable<T>) => RealArrayLike<T>;\n        };\n\n        if (typeof ctor.from === \"function\") {\n            chunks.push(ctor.from([]));\n        } else {\n            chunks.push(new ctor([]));\n        }\n    }\n\n    return chunks;\n}\n\n/** Breaks the array into smaller chunks according to the given length. */\nexport function chunk<T>(arr: RealArrayLike<T>, length: number): RealArrayLike<T>[] {\n    const limit = arr.length;\n    const size = Math.ceil(limit / length);\n    const chunks = new Array<RealArrayLike<T>>(size);\n    let offset = 0;\n    let idx = 0;\n\n    while (offset < limit) {\n        chunks[idx] = arr.slice(offset, offset + length);\n        offset += length;\n        idx++;\n    }\n\n    return chunks;\n}\n\n/** Returns a subset of the array that contains only unique items. */\nexport function uniq<T>(arr: T[]): T[] {\n    return [...new Set(arr)];\n}\n\n/**\n * Reorganizes the elements in the array in random order.\n * \n * This function mutates the array.\n */\nexport function shuffle<T>(arr: T[]): T[] {\n    for (let i = arr.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [arr[i], arr[j]] = [arr[j] as T, arr[i] as T];\n    }\n\n    return arr;\n}\n\n/**\n * Orders the items of the array according to the specified comparable `key` (whose value\n * must either be a numeric or string).\n */\nexport function orderBy<T>(arr: T[], key: keyof T, order: \"asc\" | \"desc\" = \"asc\"): T[] {\n    const items = arr.slice();\n    items.sort((a, b) => {\n        if (typeof a !== \"object\" || typeof b !== \"object\" ||\n            !a || !b ||\n            Array.isArray(a) || Array.isArray(b)\n        ) {\n            return -1;\n        }\n\n        const _a = a[key];\n        const _b = b[key];\n\n        if (_a === undefined || _b === undefined) {\n            return -1;\n        }\n\n        if (typeof _a === \"number\" && typeof _b === \"number\") {\n            return _a - _b;\n        } else if ((typeof _a === \"string\" && typeof _b === \"string\")\n            || (typeof _a === \"bigint\" && typeof _b === \"bigint\")\n        ) {\n            if (_a < _b) {\n                return -1;\n            } else if (_a > _b) {\n                return 1;\n            } else {\n                return 1;\n            }\n        } else {\n            return -1;\n        }\n    });\n\n    if (order === \"desc\") {\n        items.reverse();\n    }\n\n    return items;\n};\n\n/**\n * Groups the items of the array according to the comparable values returned by a provided\n * callback function.\n * The returned record / map has separate properties for each group, containing arrays with\n * the items in the group.\n */\nexport function groupBy<T>(\n    arr: T[],\n    fn: (item: T, i: number) => string | symbol,\n    type?: ObjectConstructor\n): Record<string | symbol, T[]>;\nexport function groupBy<T, K extends string>(\n    arr: T[],\n    fn: (item: T, i: number) => K,\n    type: MapConstructor\n): Map<K, T[]>;\nexport function groupBy<T>(\n    arr: T[],\n    fn: (item: T, i: number) => any,\n    type: ObjectConstructor | MapConstructor = Object\n): any {\n    if (type === Map) {\n        const groups = new Map<any, any[]>();\n\n        for (let i = 0; i < arr.length; i++) {\n            const item = arr[i];\n            const key = fn(item as T, i);\n            const list = groups.get(key);\n\n            if (list) {\n                list.push(item);\n            } else {\n                groups.set(key, [item]);\n            }\n        }\n\n        return groups;\n    } else {\n        const groups: Record<string | symbol, any[]> = {};\n\n        for (let i = 0; i < arr.length; i++) {\n            const item = arr[i];\n            const key = fn(item as T, i);\n            const list = groups[key];\n\n            if (list) {\n                list.push(item);\n            } else {\n                groups[key] = [item];\n            }\n        }\n\n        return groups;\n    }\n};\n","const inverse = Symbol(\"inverse\");\n\n/** Bi-directional map, keys and values are unique and map to each other. */\nexport default class BiMap<K, V> extends Map<K, V> {\n    [inverse]: Map<V, K>;\n\n    get [Symbol.toStringTag]() {\n        return \"BiMap\";\n    }\n\n    constructor(iterable: Iterable<readonly [K, V]> | null = null) {\n        super();\n        this[inverse] = new Map<V, K>();\n\n        if (iterable) {\n            for (const [key, value] of iterable) {\n                this.set(key, value);\n            }\n        }\n    }\n\n    override set(key: K, value: V): this {\n        super.set(key, value);\n        this[inverse].set(value, key);\n        return this;\n    }\n\n    getKey(value: V): K | undefined {\n        return this[inverse].get(value);\n    }\n\n    hasValue(value: V): boolean {\n        return this[inverse].has(value);\n    }\n\n    deleteValue(value: V): boolean {\n        if (this[inverse].has(value)) {\n            const key = this[inverse].get(value) as K;\n            super.delete(key);\n            this[inverse].delete(value);\n            return true;\n        }\n\n        return false;\n    }\n\n    override clear(): void {\n        super.clear();\n        this[inverse].clear();\n    }\n}\n","const internal = Symbol(\"internal\");\n\n/** Case-insensitive map, keys are case-insensitive. */\nexport default class CiMap<K extends string, V> implements Map<K, V> {\n    [internal]: Map<string, { key: K, value: V; }>;\n\n    get [Symbol.toStringTag]() {\n        return \"CiMap\";\n    }\n\n    get size() {\n        return this[internal].size;\n    }\n\n    constructor(iterable: Iterable<readonly [K, V]> | null = null) {\n        this[internal] = new Map<string, { key: K, value: V; }>();\n\n        if (iterable) {\n            for (const [key, value] of iterable) {\n                this.set(key, value);\n            }\n        }\n    }\n\n    set(key: K, value: V): this {\n        const id = String(key).toLowerCase();\n        this[internal].set(id, { key, value });\n        return this;\n    }\n\n    get(key: K): V | undefined {\n        const id = String(key).toLowerCase();\n        return this[internal].get(id)?.value;\n    }\n\n    has(key: K): boolean {\n        const id = String(key).toLowerCase();\n        return this[internal].has(id);\n    }\n\n    delete(key: K): boolean {\n        const id = String(key).toLowerCase();\n        return this[internal].delete(id);\n    }\n\n    clear(): void {\n        this[internal].clear();\n    }\n\n    * entries(): IterableIterator<[K, V]> {\n        for (const { key, value } of this[internal].values()) {\n            yield [key, value];\n        }\n    }\n\n    * keys(): IterableIterator<K> {\n        for (const { key } of this[internal].values()) {\n            yield key;\n        }\n    }\n\n    * values(): IterableIterator<V> {\n        for (const { value } of this[internal].values()) {\n            yield value;\n        }\n    }\n\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\n        this[internal].forEach(({ key, value }) => {\n            callbackfn(value, key, this);\n        }, thisArg);\n    }\n\n    [Symbol.iterator](): IterableIterator<[K, V]> {\n        return this.entries();\n    }\n}\n","\nimport { BiMap, CiMap } from \".\";\n\ndeclare global {\n    class BiMap<K, V> extends Map<K, V> {\n        getKey(value: V): K | undefined;\n        hasValue(value: V): boolean;\n        deleteValue(value: V): boolean;\n    }\n\n    class CiMap<K extends string, V> implements Map<K, V> {\n        readonly [Symbol.toStringTag]: \"CiMap\";\n        readonly size: number;\n        constructor(iterable?: Iterable<readonly [K, V]> | null);\n        set(key: K, value: V): this;\n        get(key: K): V | undefined;\n        has(key: K): boolean;\n        delete(key: K): boolean;\n        clear(): void;\n        entries(): IterableIterator<[K, V]>;\n        keys(): IterableIterator<K>;\n        values(): IterableIterator<V>;\n        forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;\n        [Symbol.iterator](): IterableIterator<[K, V]>;\n    }\n}\n\n// @ts-ignore\nglobalThis[\"BiMap\"] = BiMap;\n// @ts-ignore\nglobalThis[\"CiMap\"] = CiMap;\n","import BiMap from \"./BiMap\";\nimport CiMap from \"./CiMap\";\n\nexport { BiMap, CiMap };\n","export default class Exception extends Error {\n    readonly cause?: unknown;\n    readonly code: number = 0;\n\n    constructor(message: string, code?: number);\n    constructor(message: string, options: { cause?: unknown; code: number; });\n    constructor(message: string, options: number | { cause?: unknown; code?: number; } = 0) {\n        super(message);\n\n        if (typeof options === \"number\") {\n            this.code = options;\n        } else {\n            if (options.cause) {\n                Object.defineProperty(this, \"cause\", {\n                    configurable: true,\n                    enumerable: false,\n                    writable: true,\n                    value: options.cause,\n                });\n            }\n\n            if (options.code) {\n                this.code = options.code;\n            }\n        }\n    }\n}\n","import { Exception, fromObject, toObject } from \".\";\n\ndeclare global {\n    interface Error {\n        toJSON(): { [x: string]: any; };\n    }\n\n    interface ErrorConstructor {\n        /** Transform the error to a plain object. */\n        toObject<T extends Error>(err: T): { [x: string | symbol]: any; }\n        /** Reverse a plain object to a specific error type according to the `name` property. */\n        fromObject<T extends { name: \"Error\"; }>(obj: T): Error;\n        fromObject<T extends { name: \"EvalError\"; }>(obj: T): EvalError;\n        fromObject<T extends { name: \"RangeError\"; }>(obj: T): RangeError;\n        fromObject<T extends { name: \"ReferenceError\"; }>(obj: T): ReferenceError;\n        fromObject<T extends { name: \"SyntaxError\"; }>(obj: T): SyntaxError;\n        fromObject<T extends { name: \"TypeError\"; }>(obj: T): TypeError;\n        fromObject<T extends { name: \"URIError\"; }>(obj: T): URIError;\n        fromObject<T extends { name: \"Exception\"; }>(obj: T): Exception;\n        fromObject<T extends Error>(obj: { [x: string | symbol]: any; }): T;\n    }\n\n    class Exception extends Error {\n        readonly cause?: unknown;\n        readonly code: number;\n        constructor(message: string, code?: number);\n        constructor(message: string, options: { cause?: unknown; code?: number; });\n    }\n}\n\n//@ts-ignore\nglobalThis[\"Exception\"] = Exception;\n\nError.toObject = toObject\nError.fromObject = fromObject;\n\nError.prototype.toJSON = function toJSON() {\n    return toObject(this);\n};\n","import { omit } from \"../object\";\nimport Exception from \"./Exception\";\n\nexport { Exception };\n\n/** Transform the error to a plain object. */\nexport function toObject<T extends Error>(err: T): { [x: string | symbol]: any; } {\n    return omit(err, []);\n}\n\n/** Reverse a plain object to a specific error type according to the `name` property. */\nexport function fromObject<T extends { name: \"Error\"; }>(obj: T): Error;\nexport function fromObject<T extends { name: \"EvalError\"; }>(obj: T): EvalError;\nexport function fromObject<T extends { name: \"RangeError\"; }>(obj: T): RangeError;\nexport function fromObject<T extends { name: \"ReferenceError\"; }>(obj: T): ReferenceError;\nexport function fromObject<T extends { name: \"SyntaxError\"; }>(obj: T): SyntaxError;\nexport function fromObject<T extends { name: \"TypeError\"; }>(obj: T): TypeError;\nexport function fromObject<T extends { name: \"URIError\"; }>(obj: T): URIError;\nexport function fromObject<T extends { name: \"Exception\"; }>(obj: T): Exception;\nexport function fromObject<T extends Error>(obj: { [x: string | symbol]: any; }): T;\nexport function fromObject<T extends Error>(obj: { [x: string | symbol]: any; }): T {\n    // @ts-ignore\n    let ctor = globalThis[obj.name] as new (...args: any) => T;\n\n    if (!ctor) {\n        if (obj[\"name\"] === \"Exception\") {\n            ctor = Exception as unknown as new (...args: any) => T;\n        } else {\n            ctor = Error as unknown as new (...args: any) => T;\n        }\n    }\n\n    const err: T = Object.create(ctor.prototype, {\n        message: {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: obj[\"message\"] ?? \"\",\n        },\n    });\n\n    if (err.name !== obj[\"name\"]) {\n        Object.defineProperty(err, \"name\", {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: obj[\"name\"],\n        });\n    }\n\n    if (obj[\"stack\"] !== undefined) {\n        Object.defineProperty(err, \"stack\", {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: obj[\"stack\"],\n        });\n    }\n\n    if (obj[\"cause\"] != undefined) {\n        Object.defineProperty(err, \"cause\", {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: obj[\"cause\"],\n        });\n    }\n\n    const otherKeys = Reflect.ownKeys(obj).filter(\n        key => !([\"name\", \"message\", \"stack\", \"cause\"] as (string | symbol)[]).includes(key)\n    );\n\n    otherKeys.forEach(key => {\n        // @ts-ignore\n        err[key] = obj[key];\n    });\n\n    return err;\n}\n","import { isAsyncGenerator, isGenerator } from \"check-iterable\";\nimport type { Worker as NodeWorker } from \"worker_threads\";\nimport type { ChildProcess } from \"child_process\";\nimport { sequence } from \"./number\";\n\nexport interface Constructor<T> extends Function {\n    new(...args: any[]): T;\n    prototype: T;\n}\n\nexport interface TypedArray extends Array<number> {\n    readonly buffer: ArrayBufferLike;\n    readonly byteLength: number;\n    subarray(begin?: number, end?: number): TypedArray;\n}\n\nexport type Optional<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;\nexport type Ensured<T, K extends keyof T> = Required<Pick<T, K>> & Omit<T, K>;\n\nexport type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n\nconst isNode = typeof process === \"object\" && !!process.versions?.node;\n\ntype ThrottleCache = {\n    for: any;\n    expires?: number;\n    result?: { value?: any; error?: unknown; };\n};\nconst throttleCaches = new Map<any, ThrottleCache>();\n\n/**\n * The maximum number of workers is set to 4 times of the CPU core numbers.\n * \n * The primary purpose of the workers is not mean to run tasks in parallel, but run them in separate\n * from the main thread, so that aborting tasks can be achieved by terminating the worker thread and\n * it will not affect the main thread.\n * \n * That said, the worker thread can still be used to achieve parallelism, but it should be noticed\n * that only the numbers of tasks that equals to the CPU core numbers will be run at the same time.\n */\nconst maxWorkerNum = (() => {\n    if (isNode) {\n        return (require(\"os\").cpus().length as number) * 4;\n    } else {\n        return 16;\n    }\n})();\n\nconst workerIdCounter = sequence(1, Number.MAX_SAFE_INTEGER, 1, true);\nlet workerPool: {\n    workerId: number;\n    worker: Worker | NodeWorker | ChildProcess;\n    adapter: \"worker_threads\" | \"child_process\";\n    busy: boolean;\n}[] = [];\n\n// The worker consumer queue is nothing but a callback list, once a worker is available, the runner\n// pop a consumer and run the callback, which will retry gaining the worker and retry the task.\nconst workerConsumerQueue: (() => void)[] = [];\n\n/**\n * Merges properties and methods only if they're missing in the class. \n */\nfunction mergeIfNotExists(proto: object, source: object, mergeSuper = false) {\n    let props = Reflect.ownKeys(source);\n\n    for (let prop of props) {\n        if (prop == \"constructor\") {\n            continue;\n        } else if (mergeSuper) {\n            // When merging properties from super classes, the properties in the\n            // base class has the first priority and shall not be overwrite.\n            if (!(prop in proto)) {\n                setProp(proto, source, <string | symbol>prop);\n            }\n        } else if (!proto.hasOwnProperty(prop)) {\n            setProp(proto, source, <string | symbol>prop);\n        }\n    }\n\n    return proto;\n}\n\n/**\n * Merges properties and methods across the prototype chain.\n */\nfunction mergeHierarchy(ctor: Function, mixin: Function, mergeSuper = false) {\n    mergeIfNotExists(ctor.prototype, mixin.prototype, mergeSuper);\n\n    let _super = Object.getPrototypeOf(mixin);\n\n    // Every user defined class or functions that can be instantiated have their\n    // own names, if no name appears, that means the function has traveled to \n    // the root of the hierarchical tree.\n    if (_super.name) {\n        mergeHierarchy(ctor, _super, true);\n    }\n}\n\n/**\n * Sets property for prototype based on the given source and prop name properly.\n */\nfunction setProp(proto: any, source: any, prop: string | symbol) {\n    let desc = Object.getOwnPropertyDescriptor(source, prop);\n\n    if (desc) {\n        Object.defineProperty(proto, prop, desc);\n    } else {\n        proto[prop] = source[prop];\n    }\n}\n\nexport interface JsExt {\n    /**\n     * Runs a function and catches any error happens inside it, returns the error and result\n     * in a `[err, res]` tuple.\n     */\n    try<E = Error, T = any, A extends any[] = any[], TReturn = any, TNext = unknown>(\n        fn: (...args: A) => AsyncGenerator<T, TReturn, TNext>,\n        ...args: A\n    ): AsyncGenerator<[E | null, T], [E | null, TReturn], TNext>;\n    try<E = Error, T = any, A extends any[] = any[], TReturn = any, TNext = unknown>(\n        fn: (...args: A) => Generator<T, TReturn, TNext>,\n        ...args: A\n    ): Generator<[E | null, T], [E | null, TReturn], TNext>;\n    try<E = Error, R = any, A extends any[] = any[]>(\n        fn: (...args: A) => Promise<R>,\n        ...args: A\n    ): Promise<[E | null, R]>;\n    try<E = Error, R = any, A extends any[] = any[]>(\n        fn: (...args: A) => R,\n        ...args: A\n    ): [E | null, R];\n    /** Resolves a generator and renders its yield value in a `[err, val]` tuple. */\n    try<E = Error, T = any, TReturn = any, TNext = unknown>(\n        gen: AsyncGenerator<T, TReturn, TNext>\n    ): AsyncGenerator<[E | null, T], [E | null, TReturn], TNext>;\n    try<E = Error, T = any, TReturn = any, TNext = unknown>(\n        gen: Generator<T, TReturn, TNext>\n    ): Generator<[E | null, T], [E | null, TReturn], TNext>;\n    /** Resolves a promise and returns the error and result in a `[err, res]` tuple. */\n    try<E = Error, R = any>(job: Promise<R>): Promise<[E | null, R]>;\n\n    /**\n     * Inspired by Golang, creates a function that receives a `defer` function which can be used\n     * to carry deferred jobs that will be run after the main function is complete.\n     * \n     * Multiple calls of the `defer` function is supported, and the callbacks are called in the\n     * LIFO order. Callbacks can be async functions if the main function is an async function or\n     * an async generator function, and all the running procedures will be awaited.\n     * \n     * @example\n     *  const getVersion = await jsext.func(async (defer) => {\n     *      const file = await fs.open(\"./package.json\", \"r\");\n     *      defer(() => file.close());\n     *\n     *      const content = await file.readFile(\"utf8\");\n     *      const pkg = JSON.parse(content);\n     *\n     *      return pkg.version as string;\n     *  });\n     */\n    func<T, R = any, A extends any[] = any[]>(\n        fn: (this: T, defer: (cb: () => void) => void, ...args: A) => R\n    ): (this: T, ...args: A) => R;\n\n    /**\n     * Wraps a function inside another function and returns a new function\n     * that copies the original function's name and properties.\n     */\n    wrap<T, Fn extends (this: T, ...args: any[]) => any>(\n        fn: Fn,\n        wrapper: (this: T, fn: Fn, ...args: Parameters<Fn>) => ReturnType<Fn>\n    ): Fn;\n\n    /**\n     * Creates a throttled function that will only be run once in a certain amount of time.\n     * \n     * If a subsequent call happens within the `duration`, the previous result will be returned and\n     * the `handler` function will not be invoked.\n     */\n    throttle<T, Fn extends (this: T, ...args: any[]) => any>(handler: Fn, duration: number): Fn;\n    throttle<T, Fn extends (this: T, ...args: any[]) => any>(handler: Fn, options: {\n        duration: number;\n        /**\n         * Use the throttle strategy `for` the given key, this will keep the result in a global\n         * cache, binding new `handler` function for the same key will result in the same result\n         * as the previous, unless the duration has passed. This mechanism guarantees that both\n         * creating the throttled function in function scopes and overwriting the handler are\n         * possible.\n         */\n        for?: any;\n    }): Fn;\n\n    /**\n     * Returns an extended class that combines all mixin methods.\n     * \n     * This function does not mutates the base class but create a pivot class\n     * instead.\n     */\n    mixins<T extends Constructor<any>, M extends any[]>(\n        base: T,\n        ...mixins: { [X in keyof M]: Constructor<M[X]> }\n    ): T & Constructor<UnionToIntersection<FlatArray<M, 1>>>;\n    mixins<T extends Constructor<any>, M extends any[]>(\n        base: T,\n        ...mixins: M\n    ): T & Constructor<UnionToIntersection<FlatArray<M, 1>>>;\n\n    /**\n     * Wraps a source as an AsyncIterable object that can be used in the `for...await...` loop\n     * for reading streaming data.\n     */\n    read<I extends AsyncIterable<any>>(iterable: I): I;\n    read(es: EventSource, options?: { event?: string; }): AsyncIterable<string>;\n    read<T extends Uint8Array | string>(ws: WebSocket): AsyncIterable<T>;\n    read<T>(target: EventTarget, eventMap?: {\n        message?: string;\n        error?: string;\n        close?: string;\n    }): AsyncIterable<T>;\n    read<T>(target: NodeJS.EventEmitter, eventMap?: {\n        data?: string;\n        error?: string;\n        close?: string;\n    }): AsyncIterable<T>;\n\n    /**\n     * Runs a task in the `script` in a worker thread that can be aborted during runtime.\n     * \n     * In Node.js, the `script` can be either a CommonJS module or an ES module, and is relative to\n     * the current working directory if not absolute.\n     * \n     * In browser or Deno, the `script` can only be an ES module, and is relative to the current URL\n     * (or working directory for Deno) if not absolute.\n     */\n    run<T, A extends any[] = any[]>(script: string, args?: A, options?: {\n        /** If not set, runs the default function, otherwise runs the specific function. */\n        fn?: string;\n        /** Automatically abort the task when timeout (in milliseconds). */\n        timeout?: number;\n        /**\n         * Instead of dropping the worker after the task has completed, keep it alive so that it can\n         * be reused by other tasks.\n         */\n        keepAlive?: boolean;\n        /**\n         * In browser, this option is ignored and will always use the web worker.\n         */\n        adapter?: \"worker_threads\" | \"child_process\";\n        /**\n         * In browser, by default, the program loads the worker entry directly from GitHub, which\n         * could be slow due to poor internet connection, we can copy the entry file\n         * `esm/worker-web.mjs` to a local path of our website and set this option to that path so\n         * that it can be loaded locally.\n         */\n        webWorkerEntry?: string;\n    }): Promise<{\n        workerId: number;\n        /** Terminates the worker and abort the task. */\n        abort(): Promise<void>;\n        /** Retrieves the return value of the function. */\n        result(): Promise<T>;\n        /** Iterates the yield value if the function returns a generator. */\n        iterate(): AsyncIterable<T>;\n    }>;\n}\n\nconst jsext: JsExt = {\n    try(fn: any, ...args: any[]) {\n        if (typeof fn === \"function\") {\n            try {\n                return jsext.try(fn.apply(void 0, args));\n            } catch (err) {\n                return [err, undefined];\n            }\n        }\n\n        let returns = fn;\n        // Implementation details should be ordered from complex to simple.\n\n        if (isAsyncGenerator(returns)) {\n            return (async function* () {\n                let input: unknown;\n                let result: any;\n\n                // Use `while` loop instead of `for...of...` in order to\n                // retrieve the return value of a generator function.\n                while (true) {\n                    try {\n                        let { done, value } = await returns.next(input);\n\n                        if (done) {\n                            result = value;\n                            break;\n                        } else {\n                            // Receive any potential input value that passed\n                            // to the outer `next()` call, and pass them to\n                            // `res.next()` in the next call.\n                            input = yield Promise.resolve([null, value]);\n                        }\n                    } catch (err) {\n                        // If any error occurs, yield that error as resolved\n                        // and break the loop immediately, indicating the\n                        // process is forced broken.\n                        yield Promise.resolve([err, undefined]);\n                        break;\n                    }\n                }\n\n                return Promise.resolve([null, result]);\n            })() as AsyncGenerator<unknown, any, unknown>;\n        } else if (isGenerator(returns)) {\n            return (function* () {\n                let input: unknown;\n                let result: any;\n\n                while (true) {\n                    try {\n                        let { done, value } = returns.next(input);\n\n                        if (done) {\n                            result = value;\n                            break;\n                        } else {\n                            input = yield [null, value];\n                        }\n                    } catch (err) {\n                        yield [err, undefined];\n                        break;\n                    }\n                }\n\n                return [null, result];\n            })() as Generator<unknown, any, unknown>;\n        } else if (typeof returns?.then === \"function\") {\n            returns = (returns as PromiseLike<any>).then((value: any) => [null, value]);\n            return Promise.resolve(returns).catch((err: unknown) => [err, undefined]) as any;\n        } else {\n            return [null, returns];\n        }\n    },\n    func<T, R = any, A extends any[] = any[]>(\n        fn: (this: T, defer: (cb: () => void) => void, ...args: A) => R\n    ): (this: T, ...args: A) => R {\n        return function (this: any, ...args: A) {\n            const callbacks: (() => void)[] = [];\n            const defer = (cb: () => void) => void callbacks.push(cb);\n            type Result = { value?: Awaited<R>; error: unknown; };\n            let result: Result | undefined;\n\n            try {\n                const returns = fn.call(this, defer, ...args) as any;\n\n                if (isAsyncGenerator(returns)) {\n                    const gen = (async function* () {\n                        let input: unknown;\n\n                        // Use `while` loop instead of `for...of...` in order to\n                        // retrieve the return value of a generator function.\n                        while (true) {\n                            try {\n                                let { done, value } = await returns.next(input);\n\n                                if (done) {\n                                    result = { value, error: null };\n                                    break;\n                                } else {\n                                    // Receive any potential input value that passed\n                                    // to the outer `next()` call, and pass them to\n                                    // `res.next()` in the next call.\n                                    input = yield Promise.resolve(value);\n                                }\n                            } catch (error) {\n                                // If any error occurs, capture that error and break\n                                // the loop immediately, indicating the process is\n                                // forced broken.\n                                result = { value: void 0, error } as Result;\n                                break;\n                            }\n                        }\n\n                        for (let i = callbacks.length - 1; i >= 0; i--) {\n                            await (callbacks[i] as () => void | Promise<void>)?.();\n                        }\n\n                        if (result.error) {\n                            throw result.error;\n                        } else {\n                            return Promise.resolve(result.value);\n                        }\n                    })() as AsyncGenerator<unknown, any, unknown>;\n\n                    return gen as R;\n                } else if (isGenerator(returns)) {\n                    const gen = (function* () {\n                        let input: unknown;\n\n                        while (true) {\n                            try {\n                                let { done, value } = returns.next(input);\n\n                                if (done) {\n                                    result = { value, error: null };\n                                    break;\n                                } else {\n                                    input = yield value;\n                                }\n                            } catch (error) {\n                                result = { value: void 0, error } as Result;\n                                break;\n                            }\n                        }\n\n                        for (let i = callbacks.length - 1; i >= 0; i--) {\n                            callbacks[i]?.();\n                        }\n\n                        if (result.error) {\n                            throw result.error;\n                        } else {\n                            return result.value;\n                        }\n                    })() as Generator<unknown, R, unknown>;\n\n                    return gen as R;\n                } else if (typeof returns?.then === \"function\") {\n                    return Promise.resolve(returns as PromiseLike<R>).then(value => ({\n                        value,\n                        error: null,\n                    } as Result)).catch((error: unknown) => ({\n                        value: void 0,\n                        error,\n                    } as Result)).then(async result => {\n                        for (let i = callbacks.length - 1; i >= 0; i--) {\n                            await (callbacks[i] as () => void | Promise<void>)?.();\n                        }\n\n                        if (result.error) {\n                            throw result.error;\n                        } else {\n                            return result.value;\n                        }\n                    }) as R;\n                } else {\n                    result = { value: returns, error: null } as Result;\n                }\n            } catch (error) {\n                result = { value: void 0, error } as Result;\n            }\n\n            for (let i = callbacks.length - 1; i >= 0; i--) {\n                callbacks[i]?.();\n            }\n\n            if (result.error) {\n                throw result.error;\n            } else {\n                return result.value as R;\n            }\n        };\n    },\n    wrap<T, Fn extends (this: T, ...args: any[]) => any>(\n        fn: Fn,\n        wrapper: (this: T, fn: Fn, ...args: Parameters<Fn>) => ReturnType<Fn>\n    ): Fn {\n        const wrapped = function (this: any, ...args: Parameters<Fn>): ReturnType<Fn> {\n            return wrapper.call(this, fn, ...args);\n        };\n\n        Object.defineProperty(wrapped,\n            \"name\",\n            Object.getOwnPropertyDescriptor(fn, \"name\") as PropertyDescriptor);\n        Object.defineProperty(wrapped,\n            \"length\",\n            Object.getOwnPropertyDescriptor(fn, \"length\") as PropertyDescriptor);\n        Object.defineProperty(wrapped, \"toString\", {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: fn.toString.bind(fn),\n        });\n\n        return wrapped as Fn;\n    },\n    throttle(handler, options) {\n        const key = typeof options === \"number\" ? null : options.for;\n        const duration = typeof options === \"number\" ? options : options.duration;\n\n        const handleCall = function (\n            this: any,\n            cache: ThrottleCache,\n            ...args: any[]\n        ) {\n            if (cache.result && Date.now() < (cache.expires ?? 0)) {\n                if (cache.result.error) {\n                    throw cache.result.error;\n                } else {\n                    return cache.result.value;\n                }\n            }\n\n            try {\n                const returns = handler.call(this, ...args);\n                cache.result = { value: returns };\n                cache.expires = Date.now() + duration;\n                return returns;\n            } catch (error) {\n                cache.result = { error };\n                cache.expires = Date.now() + duration;\n                throw error;\n            }\n        };\n\n        if (!key) {\n            const cache: ThrottleCache = { for: null };\n            return function (this: any, ...args: any[]) {\n                return handleCall.call(this, cache, ...args);\n            };\n        } else {\n            let cache = throttleCaches.get(key);\n\n            if (!cache) {\n                cache = { for: key };\n                throttleCaches.set(key, cache);\n            }\n\n            return function (this: any, ...args: any[]) {\n                return handleCall.call(this, cache as ThrottleCache, ...args);\n            };\n        }\n    },\n    mixins(base, ...mixins) {\n        const obj = { ctor: null as any as Constructor<any> };\n        obj.ctor = class extends (<any>base) { }; // make sure this class has no name\n\n        for (let mixin of mixins) {\n            if (typeof mixin == \"function\") {\n                mergeHierarchy(obj.ctor, mixin);\n            } else if (mixin && typeof mixin == \"object\") {\n                mergeIfNotExists(obj.ctor.prototype, mixin);\n            } else {\n                throw new TypeError(\"mixin must be a constructor or an object\");\n            }\n        }\n\n        return obj.ctor as Constructor<any>;\n    },\n    read<T>(source: any, eventMap: {\n        event?: string; // for EventSource custom event\n        message?: string;\n        data?: string;\n        error?: string;\n        close?: string;\n    } | undefined = undefined): AsyncIterable<T> {\n        if (typeof source[Symbol.asyncIterator] === \"function\") {\n            return source;\n        }\n\n        const iterable = {\n            ended: false,\n            error: null as Error | null,\n            queue: [] as T[],\n            consumers: [] as {\n                resolve: (data: IteratorResult<T>) => void;\n                reject: (err: any) => void;\n            }[],\n            next() {\n                return new Promise<IteratorResult<T>>((resolve, reject) => {\n                    if (this.error && !this.ended) {\n                        // If there is error occurred during the last transmission and the iterator\n                        // hasn't been closed, reject that error and stop the iterator immediately.\n                        reject(this.error);\n                        this.ended = true;\n                    } else if (this.ended && !this.queue.length) {\n                        // If the iterator has is closed, resolve the pending consumer with void\n                        // value.\n                        resolve({ value: void 0 as T, done: true });\n                    } else if (this.queue.length > 0) {\n                        // If there are data in the queue, resolve the the first piece immediately.\n                        resolve({ value: this.queue.shift() as T, done: false });\n                    } else {\n                        // If there are no queued data, push the consumer to a waiting queue.\n                        this.consumers.push({ resolve, reject });\n                    }\n                });\n            }\n        };\n\n        const handleMessage = (data: T) => {\n            if (iterable.consumers.length > 0) {\n                iterable.consumers.shift()?.resolve({ value: data, done: false });\n            } else {\n                iterable.queue.push(data);\n            }\n        };\n        const handleClose = () => {\n            iterable.ended = true;\n            let consumer: typeof iterable[\"consumers\"][0] | undefined;\n\n            while (consumer = iterable.consumers.shift()) {\n                consumer.resolve({ value: undefined, done: true });\n            }\n        };\n        const handleError = (err: Error) => {\n            iterable.error = err;\n\n            if (iterable.consumers.length > 0) {\n                iterable.consumers.forEach(item => {\n                    item.reject(err);\n                });\n                iterable.consumers = [];\n            }\n        };\n        const handleBrowserErrorEvent = (ev: Event) => {\n            let err: Error;\n\n            if (ev instanceof ErrorEvent) {\n                err = ev.error || new Error(ev.message);\n            } else {\n                // @ts-ignore\n                err = new Error(\"something went wrong\", { cause: ev });\n            }\n\n            handleError(err);\n        };\n\n        const proto = Object.getPrototypeOf(source);\n        const msgDesc = Object.getOwnPropertyDescriptor(proto, \"onmessage\");\n\n        if (msgDesc?.set && typeof source.close === \"function\") { // WebSocket or EventSource\n            const errDesc = Object.getOwnPropertyDescriptor(proto, \"onerror\");\n            const closeDesc = Object.getOwnPropertyDescriptor(proto, \"onclose\");\n            let cleanup: () => void;\n\n            if (eventMap?.event &&\n                eventMap?.event !== \"message\" &&\n                typeof source[\"addEventListener\"] === \"function\"\n            ) { // for EventSource listening on custom events\n                const es = source as EventSource;\n                const eventName = eventMap.event;\n                const msgListener = (ev: MessageEvent<T>) => {\n                    handleMessage(ev.data);\n                };\n\n                es.addEventListener(eventName, msgListener);\n                cleanup = () => {\n                    es.removeEventListener(eventName, msgListener);\n                };\n            } else {\n                msgDesc.set.call(source, (ev: MessageEvent<T>) => {\n                    handleMessage(ev.data);\n                });\n                cleanup = () => {\n                    msgDesc.set?.call(source, null);\n                };\n            }\n\n            errDesc?.set?.call(source, handleBrowserErrorEvent);\n\n            if (closeDesc?.set) { // WebSocket\n                closeDesc.set.call(source, () => {\n                    handleClose();\n                    closeDesc.set?.call(source, null);\n                    errDesc?.set?.call(source, null);\n                    cleanup?.();\n                });\n            } else if (!closeDesc?.set && typeof source.close === \"function\") { // EventSource\n                // EventSource by default does not trigger close event, we need to make sure when\n                // it calls the close() function, the iterator is automatically closed.\n                const es = source as EventSource;\n                const _close = es.close;\n                es.close = function close() {\n                    _close.call(es);\n                    handleClose();\n                    es.close = _close;\n                    errDesc?.set?.call(source, null);\n                    cleanup?.();\n                };\n            }\n        } else if (typeof source.send === \"function\" && typeof source.close === \"function\") {\n            // non-standard WebSocket implementation\n            const ws = source as WebSocket;\n            ws.onmessage = (ev: MessageEvent<T>) => {\n                handleMessage(ev.data);\n            };\n            ws.onerror = handleBrowserErrorEvent;\n            ws.onclose = () => {\n                handleClose();\n                ws.onclose = null;\n                ws.onerror = null;\n                ws.onmessage = null;\n            };\n        } else if (typeof source[\"addEventListener\"] === \"function\") { // EventTarget\n            const target = source as EventTarget;\n            const msgEvent = eventMap?.message || \"message\";\n            const errEvent = eventMap?.error || \"error\";\n            const closeEvent = eventMap?.close || \"close\";\n            const msgListener = (ev: Event) => {\n                if (ev instanceof MessageEvent) {\n                    handleMessage(ev.data);\n                }\n            };\n\n            target.addEventListener(msgEvent, msgListener);\n            target.addEventListener(errEvent, handleBrowserErrorEvent);\n            target.addEventListener(closeEvent, function closeListener() {\n                handleClose();\n                target.removeEventListener(closeEvent, closeListener);\n                target.removeEventListener(msgEvent, msgListener);\n                target.removeEventListener(errEvent, handleBrowserErrorEvent);\n            });\n        } else if (typeof source[\"on\"] === \"function\") { // EventEmitter\n            const target = source as NodeJS.EventEmitter;\n            const dataEvent = eventMap?.data || \"data\";\n            const errEvent = eventMap?.error || \"error\";\n            const endEvent = eventMap?.close || \"close\";\n\n            target.on(dataEvent, handleMessage);\n            target.once(errEvent, handleError);\n            target.once(endEvent, () => {\n                handleClose();\n                target.off(dataEvent, handleMessage);\n                target.off(dataEvent, handleError);\n            });\n        } else {\n            throw new TypeError(\"the input source cannot be read as an AsyncIterable object\");\n        }\n\n        return {\n            [Symbol.asyncIterator]() {\n                return iterable;\n            }\n        };\n    },\n    async run(script, args = undefined, options = undefined) {\n        const msg = {\n            type: \"ffi\",\n            script,\n            baseUrl: \"\",\n            fn: options?.fn || \"default\",\n            args: args ?? [],\n        };\n\n        if (typeof (globalThis as any)[\"Deno\"] === \"object\") {\n            msg.baseUrl = \"file://\" + (globalThis as any)[\"Deno\"].cwd() + \"/\";\n        } else if (isNode) {\n            msg.baseUrl = \"file://\" + process.cwd() + \"/\";\n        } else if (typeof location === \"object\") {\n            msg.baseUrl = location.href;\n        }\n\n        // `buffer` is used to store data pieces yielded by generator functions before they are\n        // consumed. `error` and `result` serves similar purposes for function results.\n        const buffer: any[] = [];\n        let error: Error | null = null;\n        let result: { value: any; } | undefined;\n        let resolver: {\n            resolve: (data: any) => void;\n            reject: (err: unknown) => void;\n        } | undefined;\n        let iterator: NodeJS.EventEmitter | undefined;\n        let workerId: number | undefined;\n        let poolRecord: typeof workerPool[0] | undefined;\n        let release: () => void;\n        let terminate = () => Promise.resolve<void>(void 0);\n        let timeout = options?.timeout ? setTimeout(() => {\n            const err = new Error(`operation timeout after ${options.timeout}ms`);\n\n            if (resolver) {\n                resolver.reject(err);\n            } else {\n                error = err;\n            }\n\n            terminate();\n        }, options.timeout) : null;\n\n        const handleMessage = (msg: any) => {\n            if (msg && typeof msg === \"object\" && typeof msg.type === \"string\") {\n                if (msg.type === \"error\") {\n                    return handleError(msg.error);\n                } else if (msg.type === \"return\") {\n                    if (options?.keepAlive) {\n                        // Release before resolve.\n                        release?.();\n\n                        if (workerConsumerQueue.length) {\n                            // Queued consumer now has chance to gain the worker.\n                            workerConsumerQueue.shift()?.();\n                        }\n                    } else {\n                        terminate();\n                    }\n\n                    if (resolver) {\n                        resolver.resolve(msg.value);\n                    } else {\n                        result = { value: msg.value };\n                    }\n                } else if (msg.type === \"yield\") {\n                    if (msg.done) {\n                        // The final message of yield event is the return value.\n                        handleMessage({ type: \"return\", value: msg.value });\n                    } else {\n                        if (iterator) {\n                            iterator.emit(\"data\", msg.value);\n                        } else {\n                            buffer.push(msg.value);\n                        }\n                    }\n                }\n            }\n        };\n\n        const handleError = (err: Error | null) => {\n            if (resolver) {\n                resolver.reject(err);\n            } else if (iterator) {\n                iterator.emit(\"error\", err);\n            } else {\n                error = err;\n            }\n        };\n        const handleExit = () => {\n            if (poolRecord) {\n                // Clean the pool before resolve.\n                workerPool = workerPool.filter(record => record !== poolRecord);\n\n                if (workerConsumerQueue.length) {\n                    // Queued consumer now has chance to create new worker.\n                    workerConsumerQueue.shift()?.();\n                }\n            }\n\n            if (resolver) {\n                resolver.resolve(void 0);\n            } else if (iterator) {\n                iterator.emit(\"close\");\n            } else if (!error && !result) {\n                result = { value: void 0 };\n            }\n        };\n\n        if (isNode) {\n            const path = await import(\"path\");\n            const util = await import(\"util\");\n            const fs = await import(\"fs\");\n            const stat = util.promisify(fs.stat);\n            let _filename: string;\n            let _dirname: string;\n            let entry: string;\n\n            if (typeof __filename === \"string\") {\n                _filename = __filename;\n                _dirname = __dirname;\n            } else {\n                // Using the ES module in Node.js is very unlikely, so we just check the module\n                // filename in a simple manner, and report error if not found.\n                let [err] = await jsext.try(stat(\"package.json\"));\n\n                if (err) {\n                    throw new Error(\"the current working directory is not a Node.js module\");\n                }\n\n                _filename = process.cwd() + \"/node_modules/@ayonli/jsext/esm/index.mjs\";\n                [err] = await jsext.try(stat(_filename));\n\n                if (err) {\n                    // Assuming this is @ayonli/jsext itself.\n                    _filename = process.cwd() + \"/esm/index.mjs\";\n                    [err] = await jsext.try(stat(_filename));\n\n                    if (err) {\n                        throw new Error(\"can not locate the worker entry\");\n                    }\n                }\n\n                _dirname = path.dirname(_filename);\n            }\n\n            if (_filename.endsWith(\".js\")) { // compiled\n                entry = path.join(_dirname, \"esm\", \"worker.mjs\");\n            } else {\n                entry = path.join(path.dirname(_dirname), \"esm\", \"worker.mjs\");\n            }\n\n            if (options?.adapter === \"child_process\") {\n                let worker: ChildProcess;\n                let ok = true;\n                poolRecord = workerPool.find(item => {\n                    return item.adapter === \"child_process\" && !item.busy;\n                });\n\n                if (poolRecord) {\n                    worker = poolRecord.worker as ChildProcess;\n                    workerId = poolRecord.workerId;\n                    poolRecord.busy = true;\n                } else if (workerPool.length < maxWorkerNum) {\n                    const { fork } = await import(\"child_process\");\n                    const isPrior14 = parseInt(process.version.slice(1)) < 14;\n                    worker = fork(entry, {\n                        stdio: \"inherit\",\n                        serialization: isPrior14 ? \"advanced\" : \"json\",\n                    });\n                    workerId = worker.pid as number;\n                    ok = await new Promise<boolean>((resolve) => {\n                        worker.once(\"exit\", () => {\n                            if (error) {\n                                // The child process took too long to start and cause timeout error.\n                                resolve(false);\n                            }\n                        });\n                        worker.once(\"message\", () => {\n                            worker.removeAllListeners(\"exit\");\n                            resolve(true);\n                        });\n                    });\n\n                    // Fill the worker pool regardless the current call should keep-alive or not,\n                    // this will make sure that the total number of workers will not exceed the\n                    // maxWorkerNum. If the the call doesn't keep-alive the worker, it will be\n                    // cleaned after the call.\n                    ok && workerPool.push(poolRecord = {\n                        workerId,\n                        worker,\n                        adapter: \"child_process\",\n                        busy: true,\n                    });\n                } else {\n                    // Put the current call in the consumer queue if there are no workers available,\n                    // once an existing call finishes, the queue will pop the its head consumer and\n                    // retry.\n                    return new Promise<void>((resolve) => {\n                        workerConsumerQueue.push(resolve);\n                    }).then(() => jsext.run(script, args, options));\n                }\n\n                release = () => {\n                    // Remove the event listener so that later calls will not mess up.\n                    worker.off(\"message\", handleMessage);\n                    poolRecord && (poolRecord.busy = false);\n                };\n                terminate = () => Promise.resolve(void worker.kill(1));\n\n                if (ok) {\n                    worker.send(msg);\n                    worker.on(\"message\", handleMessage);\n                    worker.once(\"error\", handleError);\n                    worker.once(\"exit\", handleExit);\n                }\n            } else {\n                let worker: NodeWorker;\n                let ok = true;\n                poolRecord = workerPool.find(item => {\n                    return item.adapter === \"worker_threads\" && !item.busy;\n                });\n\n                if (poolRecord) {\n                    worker = poolRecord.worker as NodeWorker;\n                    workerId = poolRecord.workerId;\n                    poolRecord.busy = true;\n                } else if (workerPool.length < maxWorkerNum) {\n                    const { Worker } = await import(\"worker_threads\");\n                    worker = new Worker(entry);\n                    workerId = worker.threadId;\n                    ok = await new Promise<boolean>((resolve) => {\n                        worker.once(\"exit\", () => {\n                            if (error) {\n                                // The child process took too long to start and cause timeout error.\n                                resolve(false);\n                            }\n                        });\n                        worker.once(\"online\", () => {\n                            worker.removeAllListeners(\"exit\");\n                            resolve(true);\n                        });\n                    });\n                    ok && workerPool.push(poolRecord = {\n                        workerId,\n                        worker,\n                        adapter: \"worker_threads\",\n                        busy: true,\n                    });\n                } else {\n                    return new Promise<void>((resolve) => {\n                        workerConsumerQueue.push(resolve);\n                    }).then(() => jsext.run(script, args, options));\n                }\n\n                release = () => {\n                    worker.off(\"message\", handleMessage);\n                    poolRecord && (poolRecord.busy = false);\n                };\n                terminate = async () => void (await worker.terminate());\n\n                if (ok) {\n                    worker.postMessage(msg);\n                    worker.on(\"message\", handleMessage);\n                    worker.once(\"error\", handleError);\n                    worker.once(\"messageerror\", handleError);\n                    worker.once(\"exit\", handleExit);\n                }\n            }\n        } else {\n            let worker: Worker;\n            poolRecord = workerPool.find(item => {\n                return item.adapter === \"worker_threads\" && !item.busy;\n            });\n\n            if (poolRecord) {\n                worker = poolRecord.worker as Worker;\n                workerId = poolRecord.workerId;\n                poolRecord.busy = true;\n            } else if (workerPool.length < maxWorkerNum) {\n                const _url = options?.webWorkerEntry\n                    || \"https://raw.githubusercontent.com/ayonli/jsext/main/esm/worker-web.mjs\";\n                let url: string;\n\n                if (typeof (globalThis as any)[\"Deno\"] === \"object\") {\n                    // Deno can load the module regardless of MINE type.\n                    url = new URL(_url, msg.baseUrl).href;\n                } else {\n                    const res = await fetch(_url);\n\n                    if (res.headers.get(\"content-type\")?.startsWith(\"application/javascript\")) {\n                        url = _url;\n                    } else {\n                        // GitHub returns MIME type `text/plain` for the file, we need to change it\n                        // to `application/javascript`, by creating a new blob a with custom type\n                        // and using URL.createObjectURL() to create a `blob:` URL for the resource\n                        // so that it can be loaded by the Worker constructor.\n                        const buf = await res.arrayBuffer();\n                        const blob = new Blob([new Uint8Array(buf)], {\n                            type: \"application/javascript\",\n                        });\n                        url = URL.createObjectURL(blob);\n                    }\n                }\n\n                worker = new Worker(url, { type: \"module\" });\n                workerId = workerIdCounter.next().value as number;\n                workerPool.push(poolRecord = {\n                    workerId,\n                    worker,\n                    adapter: \"worker_threads\",\n                    busy: true,\n                });\n            } else {\n                return new Promise<void>((resolve) => {\n                    workerConsumerQueue.push(resolve);\n                }).then(() => jsext.run(script, args, options));\n            }\n\n            release = () => {\n                worker.onmessage = null;\n                poolRecord && (poolRecord.busy = false);\n            };\n            terminate = async () => {\n                await Promise.resolve(worker.terminate());\n                handleExit();\n            };\n\n            worker.postMessage(msg);\n            worker.onmessage = (ev) => handleMessage(ev.data);\n            worker.onerror = (ev) => handleMessage(ev.error || new Error(ev.message));\n            worker.onmessageerror = () => {\n                handleError(new Error(\"unable to deserialize the message\"));\n            };\n        }\n\n        return {\n            workerId,\n            async abort() {\n                timeout && clearTimeout(timeout);\n                await terminate();\n            },\n            async result() {\n                return await new Promise<any>((resolve, reject) => {\n                    if (error) {\n                        reject(error);\n                    } else if (result) {\n                        resolve(result.value);\n                    } else {\n                        resolver = { resolve, reject };\n                    }\n                });\n            },\n            async *iterate() {\n                if (resolver) {\n                    throw new Error(\"result() has been called\");\n                } else if (result) {\n                    throw new TypeError(\"the response is not iterable\");\n                }\n\n                const { EventEmitter } = await import(\"events\");\n                iterator = new EventEmitter();\n\n                if (buffer.length) {\n                    (async () => {\n                        await Promise.resolve(null);\n                        let msg: any;\n\n                        while (msg = buffer.shift()) {\n                            iterator.emit(\"data\", msg);\n                        }\n                    })().catch(console.error);\n                }\n\n                for await (const msg of jsext.read<any>(iterator)) {\n                    yield msg;\n                }\n            },\n        };\n    }\n};\n\nexport default jsext;\n","import { avg, product, sum } from \".\";\n\ndeclare global {\n    interface Math {\n        /** Returns the sum value of the given values. */\n        sum(...values: number[]): number;\n        /** Returns the average value of the given values. */\n        avg(...values: number[]): number;\n        /** Returns a the product value multiplied by the given values. */\n        product(...values: number[]): number;\n    }\n}\n\nMath.sum = sum;\nMath.avg = avg;\nMath.product = product;\n","/** Returns the sum value of the given values. */\nexport function sum(...values: number[]): number {\n    return values.reduce((sum, value) => sum + value, 0);\n};\n\n/** Returns the average value of the given values. */\nexport function avg(...values: number[]): number {\n    return Math.sum(...values) / values.length;\n};\n\n/** Returns a the product value multiplied by the given values. */\nexport function product(...values: number[]): number {\n    return values.slice(1).reduce((sum, value) => sum * value, values[0] ?? 0);\n};\n","import { isFloat, random, sequence } from \".\";\n\ndeclare global {\n    interface NumberConstructor {\n        /** Returns true if the given value is a float, false otherwise. */\n        isFloat(value: unknown): boolean;\n        /** Returns a random integer ranged from `min` to `max` (inclusive). */\n        random(min: number, max: number): number;\n        /** Creates a generator that produces sequential numbers from `min` to `max` (inclusive). */\n        sequence(min: number, max: number, step?: number, loop?: boolean): Generator<number, void, unknown>;\n    }\n}\n\nNumber.isFloat = isFloat;\nNumber.random = random;\nNumber.sequence = sequence;\n","/** Returns true if the given value is a float, false otherwise. */\nexport function isFloat(value: unknown): boolean {\n    return typeof value === \"number\"\n        && !Number.isNaN(value)\n        && (!Number.isFinite(value) || (value as number) % 1 !== 0);\n}\n\n/** Returns a random integer ranged from `min` to `max`. */\nexport function random(min: number, max: number): number {\n    return min + Math.floor(Math.random() * (max - min + 1));\n}\n\n/** Creates a generator that produces sequential numbers from `min` to `max` (inclusive). */\nexport function* sequence(min: number, max: number, step = 1, loop = false) {\n    let id = min;\n\n    while (true) {\n        yield id;\n\n        if (id >= max) {\n            if (loop) {\n                id = min;\n            } else {\n                break;\n            }\n        } else {\n            id += step;\n        }\n    }\n}\n","import { hasOwn, hasOwnMethod, omit, patch, pick, as } from \".\";\n\ndeclare global {\n    interface ObjectConstructor {\n        hasOwn(obj: any, key: string | number | symbol): boolean;\n        /**\n         * Returns `true` if the specified object has the indicated method as its own method (in its\n         * own prototype). If the method is inherited, or is not in the prototype, or does not exist,\n         * this function returns `false`.\n         */\n        hasOwnMethod(obj: any, method: string | symbol): boolean;\n        /**\n         * Copies the key-value pairs that are presented in the source objects but are missing in\n         * the target object into the target, later pairs are skipped if the same key already exists.\n         * \n         * This function mutates the target object and returns it.\n         */\n        patch<T extends {}, U>(target: T, source: U): T & U;\n        patch<T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V;\n        patch<T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\n        patch(target: object, ...sources: any[]): any;\n        /** Creates an object composed of the picked keys. */\n        pick<T extends object, U extends keyof T>(obj: T, keys: U[]): Pick<T, U>;\n        pick<T>(obj: T, keys: (string | symbol)[]): Partial<T>;\n        /**\n         * Creates an object composed without the picked keys.\n         * \n         * NOTE: this function only collect keys from the object's own properties, except for type\n         * Error, whose `name`, `message` and `cause` are always collected.\n         */\n        omit<T extends object, U extends keyof T>(obj: T, keys: U[]): Omit<T, U>;\n        omit<T>(obj: T, keys: (string | symbol)[]): Partial<T>;\n        /**\n         * Returns the object if it's an instance of the given type, otherwise returns `null`.\n         * This function is mainly used for the optional chaining syntax.\n         * @example\n         *  Object.as(bar, SomeType)?.doSomething();\n         */\n        as(obj: any, type: StringConstructor): string | null;\n        as(obj: any, type: NumberConstructor): number | null;\n        as(obj: any, type: BigIntConstructor): bigint | null;\n        as(obj: any, type: BooleanConstructor): boolean | null;\n        as(obj: any, type: SymbolConstructor): symbol | null;\n        as<T>(obj: any, type: Constructor<T>): T | null;\n    }\n}\n\nif (!Object.hasOwn) {\n    Object.hasOwn = hasOwn;\n}\n\nif (!Object.hasOwnMethod) {\n    Object.hasOwnMethod = hasOwnMethod;\n}\n\nObject.patch = patch;\nObject.pick = pick;\nObject.omit = omit;\nObject.as = as;\n","import type { Constructor } from \"../index\";\n\nexport function hasOwn(obj: any, key: string | number | symbol): boolean {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\n/**\n * Returns `true` if the specified object has the indicated method as its own method (in its own\n * prototype). If the method is inherited, or is not in the prototype, or does not exist, this\n * function returns `false`.\n */\nexport function hasOwnMethod(obj: any, method: string | symbol): boolean {\n    let proto = Object.getPrototypeOf(obj);\n\n    if (!proto || !hasOwn(proto, method)) {\n        return false;\n    }\n\n    return typeof Object.getOwnPropertyDescriptor(proto, method)?.value === \"function\";\n}\n\n/**\n * Copies the key-value pairs that are presented in the source objects but are missing in\n * the target object into the target, later pairs are skipped if the same key already exists.\n * \n * This function mutates the target object and returns it.\n */\nexport function patch<T extends {}, U>(target: T, source: U): T & U;\nexport function patch<T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V;\nexport function patch<T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function patch(target: object, ...sources: any[]): any;\nexport function patch(target: any, ...sources: any[]) {\n    for (const source of sources) {\n        for (const key of Reflect.ownKeys(source)) {\n            if (!hasOwn(target, key) || target[key] === undefined) {\n                target[key] = source[key];\n            }\n        }\n    }\n\n    return target;\n};\n\n/** Creates an object composed of the picked keys. */\nexport function pick<T extends object, U extends keyof T>(obj: T, keys: U[]): Pick<T, U>;\nexport function pick<T>(obj: T, keys: (string | symbol)[]): Partial<T>;\nexport function pick(obj: any, keys: (string | symbol)[]) {\n    return keys.reduce((result: any, key: string | symbol) => {\n        if (key in obj && obj[key] !== undefined) {\n            result[key] = obj[key];\n        }\n\n        return result;\n    }, {});\n}\n\n/**\n * Creates an object composed without the picked keys.\n * \n * NOTE: this function only collect keys from the object's own properties, except for type\n * Error, whose `name`, `message` and `cause` are always collected.\n */\nexport function omit<T extends object, U extends keyof T>(obj: T, keys: U[]): Omit<T, U>;\nexport function omit<T>(obj: T, keys: (string | symbol)[]): Partial<T>;\nexport function omit(obj: any, keys: (string | symbol)[]) {\n    const allKeys = Reflect.ownKeys(obj);\n    const keptKeys = allKeys.filter(key => !keys.includes(key));\n    const result = pick(obj, keptKeys);\n\n    // special treatment for Error types\n    if (obj instanceof Error) {\n        [\"name\", \"message\", \"cause\"].forEach(key => {\n            if (!keys.includes(key) &&\n                (obj as any)[key] !== undefined &&\n                !hasOwn(result, key)\n            ) {\n                result[key] = (obj as any)[key];\n            }\n        });\n    }\n\n    return result;\n}\n\n/**\n * Returns the object if it's an instance of the given type, otherwise returns `null`.\n * This function is mainly used for the optional chaining syntax.\n * @example\n *  as(bar, SomeType)?.doSomething();\n */\nexport function as(obj: any, type: StringConstructor): string | null;\nexport function as(obj: any, type: NumberConstructor): number | null;\nexport function as(obj: any, type: BigIntConstructor): bigint | null;\nexport function as(obj: any, type: BooleanConstructor): boolean | null;\nexport function as(obj: any, type: SymbolConstructor): symbol | null;\nexport function as<T>(obj: any, type: Constructor<T>): T | null;\nexport function as(obj: any, type: any): any {\n    if (typeof type !== \"function\") {\n        throw new TypeError(\"type must be a valid constructor\");\n    }\n\n    let _type: any;\n    let primitiveMap = <Record<string, Function>>{\n        \"string\": String,\n        \"number\": Number,\n        \"bigint\": BigInt,\n        \"boolean\": Boolean,\n        \"symbol\": Symbol\n    };\n\n    if (obj instanceof type) {\n        if ([String, Number, Boolean].includes(type)) {\n            return obj.valueOf(); // make sure the primitives are returned.\n        } else {\n            return obj;\n        }\n    } else if ((_type = typeof obj) && primitiveMap[_type] === type) {\n        return obj;\n    }\n\n    return null;\n}\n","import { after, sleep, timeout, until } from \".\";\n\ndeclare global {\n    interface PromiseConstructor {\n        /** Try to resolve a promise with a timeout limit. */\n        timeout<T>(value: T | Promise<T>, ms: number): Promise<T>;\n        /** Resolves a promise only after the given duration. */\n        after<T>(value: T | PromiseLike<T>, ms: number): Promise<T>;\n        /** Blocks the context for a given time. */\n        sleep(ms: number): Promise<void>;\n        /** Blocks the context until the test is passed. */\n        until(test: () => boolean | Promise<boolean>): Promise<void>;\n    }\n}\n\nPromise.timeout = timeout;\nPromise.after = after;\nPromise.sleep = sleep;\nPromise.until = until;\n","/** Try to resolve a promise with a timeout limit. */\nexport async function timeout<T>(value: T | PromiseLike<T>, ms: number): Promise<T> {\n    const result = await Promise.race([\n        value,\n        new Promise<T>((_, reject) => setTimeout(() => {\n            reject(new Error(`operation timeout after ${ms}ms`));\n        }, ms))\n    ]);\n    return result;\n}\n\n/** Resolves a promise only after the given duration. */\nexport async function after<T>(value: T | PromiseLike<T>, ms: number): Promise<T> {\n    const [result] = await Promise.allSettled([\n        value,\n        new Promise<void>(resolve => setTimeout(resolve, ms))\n    ]);\n\n    if (result.status === \"fulfilled\") {\n        return result.value;\n    } else {\n        throw result.reason;\n    }\n}\n\n/** Blocks the context for a given time. */\nexport async function sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/** Blocks the context until the test is passed. */\nexport async function until(test: () => boolean | Promise<boolean>): Promise<void> {\n    if (typeof globalThis.setImmediate === \"undefined\") {\n        // @ts-ignore\n        globalThis.setImmediate = (cb: () => void) => setTimeout(cb, 0);\n    }\n\n    do { await new Promise<void>(globalThis.setImmediate); } while ((await test()) == false);\n}\n","import {\n    compare,\n    random,\n    byteLength as _byteLength,\n    capitalize as _capitalize,\n    chunk as _chunk,\n    count as _count,\n    hyphenate as _hyphenate,\n    truncate as _truncate,\n    words as _words\n} from \".\";\n\ndeclare global {\n    interface StringConstructor {\n        /**\n         * Compares two strings, returns `-1` if `a < b`, `0` if `a == b` and `1` if `a > b`.\n         */\n        compare(str1: string, str2: string): -1 | 0 | 1;\n        /** Returns a random string, the charset matches `/[0-9a-zA-Z]/` */\n        random(length: number): string;\n    }\n\n    interface String {\n        /** Counts the occurrence of the sub-string in the string. */\n        count(sub: string): number;\n        /**\n         * Capitalizes the string, if `all` is true, all words are capitalized, otherwise only\n         * the first word will be capitalized.\n         */\n        capitalize(all?: boolean): string;\n        /** Replaces the spaces between non-empty characters of the string with hyphens (`-`). */\n        hyphenate(): string;\n        /** Extracts words (in latin characters) from the string. */\n        words(): string[];\n        /** Breaks the string into smaller chunks according to the given length. */\n        chunk(length: number): string[];\n        /** Truncates the string to the given length (including the ending `...`). */\n        truncate(length: number): string;\n        /** Returns the byte length of the string. */\n        byteLength(): number;\n    }\n}\n\nString.compare = compare;\nString.random = random;\n\nString.prototype.count = function count(sub) {\n    return _count(String(this), sub);\n};\n\nString.prototype.capitalize = function capitalize(all) {\n    return _capitalize(String(this), all);\n};\n\nString.prototype.hyphenate = function capitalize() {\n    return _hyphenate(String(this));\n};\n\nString.prototype.words = function words() {\n    return _words(String(this));\n};\n\nString.prototype.chunk = function chunk(length) {\n    return _chunk(String(this), length);\n};\n\nString.prototype.truncate = function truncate(length) {\n    return _truncate(String(this), length);\n};\n\nString.prototype.byteLength = function byteLength() {\n    return _byteLength(String(this));\n};\n","import { chunk as _chunk } from \"../array\";\n\n/**\n * Compares two strings, returns `-1` if `a < b`, `0` if `a == b` and `1` if `a > b`.\n */\nexport function compare(str1: string, str2: string): -1 | 0 | 1 {\n    if (str1 < str2) {\n        return -1;\n    } else if (str1 > str2) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/** Returns a random string, the charset matches `/[0-9a-zA-Z]/` */\nexport function random(length: number): string {\n    const chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let str = \"\";\n\n    while (0 < length--) {\n        const i = Math.floor(Math.random() * chars.length);\n        str += chars[i];\n    }\n\n    return str;\n}\n\n/** Counts the occurrence of the sub-string in the string. */\nexport function count(str: string, sub: string): number {\n    if (!sub) {\n        return str.length + 1;\n    } else if (!str) {\n        return 0;\n    }\n\n    return str.split(sub).length - 1;\n}\n\n/**\n * Capitalizes the string, if `all` is true, all words are capitalized, otherwise only\n * the first word will be capitalized.\n */\nexport function capitalize(str: string, all?: boolean): string {\n    const regex = all ? /\\w+/g : /\\w+/;\n    return str.replace(regex, (match) => {\n        return (match[0] as string).toUpperCase() + match.slice(1).toLowerCase();\n    });\n}\n\n/** Replaces the spaces between non-empty characters of the string with hyphens (`-`). */\nexport function hyphenate(str: string): string {\n    return str.replace(/(\\S)\\s+(\\S)/g, (_, $1, $2) => $1 + \"-\" + $2);\n}\n\n/** Extracts words (in latin characters) from the string. */\nexport function words(str: string): string[] {\n    const matches = str.match(/\\w+/g);\n    return matches ? [...matches] : [];\n}\n\n/** Breaks the string into smaller chunks according to the given length. */\nexport function chunk(str: string, length: number): string[] {\n    return _chunk(str, length) as string[];\n}\n\n/** Truncates the string to the given length (including the ending `...`). */\nexport function truncate(str: string, length: number): string {\n    if (length <= 0) {\n        return \"\";\n    } else if (length >= str.length) {\n        return str;\n    } else {\n        length -= 3;\n        return str.slice(0, length) + \"...\";\n    }\n}\n\nconst encoder = new TextEncoder();\n/** Returns the byte length of the string. */\nexport function byteLength(str: string): number {\n    return encoder.encode(str).byteLength;\n};\n","import { compare, equals as _equals, split as _split, chunk as _chunk } from \".\";\n\ndeclare global {\n    interface Uint8ArrayConstructor {\n        /** Like `Buffer.compare` but for pure `Uint8Array`. */\n        compare(arr1: Uint8Array, arr2: Uint8Array): -1 | 0 | 1;\n    }\n\n    interface Uint8Array {\n        /**\n         * Compare this array to another array and see if it contains the same elements as\n         * this array.\n         */\n        equals(another: Uint8Array): boolean;\n        /** Breaks the array into smaller chunks according to the given delimiter. */\n        split(delimiter: number): this[];\n        /** Breaks the array into smaller chunks according to the given length. */\n        chunk(length: number): this[];\n    }\n}\n\nUint8Array.compare = compare;\n\nUint8Array.prototype.equals = function equals(another) {\n    return _equals(this, another);\n};\n\nUint8Array.prototype.split = function split(delimiter) {\n    return _split(this, delimiter);\n};\n\nUint8Array.prototype.chunk = function chunk(length) {\n    return _chunk(this, length);\n};\n","import { equals as _equals, split as _split, chunk as _chunk } from \"../array\";\n\n/** Like `Buffer.compare` but for pure `Uint8Array`. */\nexport function compare(arr1: Uint8Array, arr2: Uint8Array): -1 | 0 | 1 {\n    if (arr1 === arr2) {\n        return 0;\n    }\n\n    for (let i = 0; i < arr1.length; i++) {\n        const ele1 = arr1[i] as number;\n        const ele2 = arr2[i];\n\n        if (ele2 === undefined) {\n            return 1;\n        } else if (ele1 < ele2) {\n            return -1;\n        } else if (ele1 > ele2) {\n            return 1;\n        }\n    }\n\n    return arr1.length < arr2.length ? -1 : 0;\n}\n\n/**\n * Compare this array to another array and see if it contains the same elements as\n * this array.\n */\nexport function equals(arr1: Uint8Array, arr2: Uint8Array): boolean {\n    if (!(arr1 instanceof Uint8Array) || !(arr2 instanceof Uint8Array)) {\n        return false;\n    }\n\n    return _equals(arr1, arr2);\n}\n\n/** Breaks the array into smaller chunks according to the given delimiter. */\nexport function split<T extends Uint8Array>(arr: T, delimiter: number): T[] {\n    return _split(arr, delimiter) as T[];\n}\n\n/** Breaks the array into smaller chunks according to the given length. */\nexport function chunk<T extends Uint8Array>(arr: T, length: number): T[] {\n    return _chunk(arr, length) as T[];\n}\n","module.exports = require(\"child_process\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"util\");","module.exports = require(\"worker_threads\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import \"./string/augment\";\nimport \"./number/augment\";\nimport \"./array/augment\";\nimport \"./uint8array/augment\";\nimport \"./object/augment\";\nimport \"./math/augment\";\nimport \"./promise/augment\";\nimport \"./collections/augment\";\nimport \"./error/augment\";\nimport jsext from \"./index\";\n\nexport default jsext;\n\ndeclare global {\n    interface Constructor<T> extends Function {\n        new(...args: any[]): T;\n        prototype: T;\n    }\n\n    interface TypedArray extends Array<number> {\n        readonly buffer: ArrayBufferLike;\n        readonly byteLength: number;\n        subarray(begin?: number, end?: number): TypedArray;\n    }\n\n    type Optional<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;\n    type Ensured<T, K extends keyof T> = Required<Pick<T, K>> & Omit<T, K>;\n}\n"],"names":["root","factory","exports","module","define","amd","this","_typeof","obj","Symbol","iterator","constructor","prototype","isIteratorLike","next","isIterableIterator","isAsyncIterableIterator","asyncIterator","hasGeneratorSpecials","Object","defineProperty","value","isIterable","isAsyncIterable","isGenerator","isAsyncGenerator","Array","first","last","length","count","ele","equals","another","split","delimiter","chunk","uniq","shuffle","toShuffled","slice","toReversed","reverse","toSorted","fn","sort","orderBy","key","order","groupBy","type","arr","i","arr1","arr2","chunks","limit","offset","push","ctor","from","size","Math","ceil","idx","Set","j","floor","random","items","a","b","isArray","_a","_b","undefined","Map","groups","item","list","get","set","inverse","BiMap","toStringTag","iterable","super","getKey","hasValue","has","deleteValue","delete","clear","internal","CiMap","id","String","toLowerCase","entries","values","keys","forEach","callbackfn","thisArg","globalThis","Exception","Error","message","options","code","cause","configurable","enumerable","writable","toObject","fromObject","toJSON","err","omit","name","create","Reflect","ownKeys","filter","includes","isNode","process","versions","node","throttleCaches","maxWorkerNum","workerIdCounter","sequence","Number","MAX_SAFE_INTEGER","workerPool","workerConsumerQueue","mergeIfNotExists","proto","source","mergeSuper","props","prop","setProp","hasOwnProperty","mergeHierarchy","mixin","_super","getPrototypeOf","desc","getOwnPropertyDescriptor","jsext","args","try","apply","returns","input","result","done","Promise","resolve","then","catch","func","callbacks","defer","cb","call","gen","error","async","wrap","wrapper","wrapped","toString","bind","throttle","handler","for","duration","handleCall","cache","Date","now","expires","mixins","base","TypeError","read","eventMap","ended","queue","consumers","reject","shift","handleMessage","data","handleClose","consumer","handleError","handleBrowserErrorEvent","ev","ErrorEvent","msgDesc","close","errDesc","closeDesc","cleanup","event","es","eventName","msgListener","addEventListener","removeEventListener","_close","send","ws","onmessage","onerror","onclose","target","msgEvent","errEvent","closeEvent","MessageEvent","closeListener","dataEvent","endEvent","on","once","off","run","script","msg","baseUrl","cwd","location","href","buffer","resolver","workerId","poolRecord","release","terminate","timeout","setTimeout","keepAlive","emit","handleExit","record","path","util","fs","_filename","_dirname","entry","promisify","stat","__filename","__dirname","endsWith","join","dirname","adapter","worker","ok","find","busy","fork","isPrior14","parseInt","version","stdio","serialization","pid","removeAllListeners","kill","Worker","threadId","postMessage","_url","webWorkerEntry","url","URL","res","fetch","headers","startsWith","buf","arrayBuffer","blob","Blob","Uint8Array","createObjectURL","onmessageerror","abort","clearTimeout","iterate","EventEmitter","console","sum","avg","product","reduce","isFloat","isNaN","isFinite","min","max","step","loop","hasOwn","hasOwnMethod","patch","pick","as","method","sources","keptKeys","_type","primitiveMap","BigInt","Boolean","valueOf","after","sleep","until","ms","race","_","allSettled","status","reason","test","setImmediate","compare","sub","capitalize","all","hyphenate","words","truncate","byteLength","str1","str2","str","chars","regex","replace","match","toUpperCase","$1","$2","matches","encoder","TextEncoder","encode","ele1","ele2","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}
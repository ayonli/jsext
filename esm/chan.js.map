{"version":3,"file":"chan.js","sources":["../chan.ts"],"sourcesContent":["export class Channel {\n    constructor(capacity = 0) {\n        this.buffer = [];\n        this.state = 1;\n        if (capacity < 0) {\n            throw new RangeError(\"the capacity of a channel must not be negative\");\n        }\n        this.capacity = capacity;\n    }\n    /**\n     * Pushes data to the channel.\n     *\n     * If there is a receiver, the data will be consumed immediately. Otherwise:\n     *\n     * - If this is an non-buffered channel, this function will block until a receiver is\n     *  available and the data is consumed.\n     *\n     * - If this is a buffered channel, then:\n     *      - If the buffer size is within the capacity, the data will be pushed to the buffer.\n     *      - Otherwise, this function will block until there is new space for the data in the\n     *          buffer.\n     */\n    push(data) {\n        if (this.state !== 1) {\n            throw new Error(\"the channel is closed\");\n        }\n        else if (this.sub) {\n            return Promise.resolve(this.sub(null, data));\n        }\n        else if (this.capacity && this.buffer.length < this.capacity) {\n            this.buffer.push(data);\n            return Promise.resolve(undefined);\n        }\n        else {\n            return new Promise(resolve => {\n                this.pub = () => {\n                    if (this.capacity) {\n                        const _data = this.buffer.shift();\n                        this.buffer.push(data);\n                        this.pub = undefined;\n                        resolve();\n                        return _data;\n                    }\n                    else {\n                        this.pub = undefined;\n                        resolve();\n                        return data;\n                    }\n                };\n            });\n        }\n    }\n    /**\n     * Retrieves data from the channel.\n     *\n     * If there isn't data available at the moment, this function will block until new data is\n     * available.\n     *\n     * If the channel is closed, then:\n     *\n     * - If there is error set in the channel, this function throws that error immediately.\n     * - Otherwise, this function returns `undefined` immediately.\n     */\n    pop() {\n        if (this.buffer.length) {\n            const data = this.buffer.shift();\n            if (this.state === 2 && !this.buffer.length) {\n                this.state = 0;\n            }\n            return Promise.resolve(data);\n        }\n        else if (this.pub) {\n            this.state === 2 && (this.state = 0);\n            return Promise.resolve(this.pub());\n        }\n        else if (this.state === 0) {\n            return Promise.resolve(undefined);\n        }\n        else if (this.error) {\n            // Error can only be consumed once, after that, that closure will be complete.\n            const { error } = this;\n            this.state = 0;\n            this.error = undefined;\n            return Promise.reject(error);\n        }\n        else if (this.state === 2) {\n            this.state = 0;\n            return Promise.resolve(undefined);\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.sub = (err, data) => {\n                    this.state === 2 && (this.state = 0);\n                    this.sub = undefined;\n                    err ? reject(err) : resolve(data);\n                };\n            });\n        }\n    }\n    /**\n     * Closes the channel. If `err` is supplied, it will be captured by the receiver.\n     *\n     * No more data shall be sent once the channel is closed.\n     *\n     * Explicitly closing the channel is not required, if the channel is no longer used, it\n     * will be automatically released by the GC. However, if the channel is used in a\n     * `for await...of...` loop, closing the channel will allow the loop to break automatically.\n     */\n    close(err = null) {\n        var _a;\n        this.state = 2;\n        this.error = err;\n        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.call(this, err, undefined);\n    }\n    [Symbol.asyncIterator]() {\n        const channel = this;\n        return {\n            async next() {\n                const bufSize = channel.buffer.length;\n                const value = await channel.pop();\n                return { value: value, done: channel.state === 0 && !bufSize };\n            }\n        };\n    }\n}\n/**\n * Inspired by Golang, cerates a channel that can be used to transfer data within the program.\n *\n * Unlike `EventEmitter` or `EventTarget`, `Channel` guarantees the data will always be delivered,\n * even if there is no receiver at the moment.\n *\n * If `capacity` is not set, a non-buffered channel will be created. For a non-buffered channel,\n * the sender and receiver must be present at the same time (theoretically), otherwise, the\n * channel will block (non-IO aspect).\n *\n * If `capacity` is set, a buffered channel will be created. For a buffered channel, data will\n * be queued in the buffer first and then consumed by the receiver in FIFO order. Once the\n * buffer size reaches the capacity limit, no more data will be sent unless there is new space\n * available.\n *\n * It is possible to set the `capacity` to `Infinity` to allow the channel to never block and\n * behave like a message queue.\n *\n * @example\n * ```ts\n * const channel = chan<number>();\n *\n * (async () => {\n *     await channel.push(123);\n * })();\n *\n * const num = await channel.pop();\n * console.log(num);\n * // output:\n * // 123\n * ```\n *\n * @example\n * ```ts\n * const channel = chan<number>(3);\n *\n * await channel.push(123);\n * await channel.push(456);\n * await channel.push(789);\n *\n * const num1 = await channel.pop();\n * const num2 = await channel.pop();\n * const num3 = await channel.pop();\n *\n * console.log(num1);\n * console.log(num2);\n * console.log(num3);\n * // output:\n * // 123\n * // 456\n * // 789\n * ```\n *\n * @example\n * ```ts\n * const channel = chan<number>();\n *\n * (async () => {\n *     for (const num of Number.sequence(1, 5)) {\n *         await channel.push(num);\n *     }\n *\n *     channel.close();\n * })();\n *\n * for await (const num of channel) {\n *     console.log(num);\n * }\n * // output:\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * ```\n */\nexport default function chan(capacity = 0) {\n    return new Channel(capacity);\n}\n//# sourceMappingURL=chan.js.map"],"names":[],"mappings":"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"}
{"version":3,"file":"index.js","sources":["../../path/index.ts"],"sourcesContent":["/**\n * Platform-independent utility functions for dealing with system paths and URLs.\n * @experimental\n * @module\n */\nimport { stripEnd, trim } from \"../string/index.ts\";\nimport { endsWith, isAbsolute, isFileProtocol, isFileUrl, isNotQuery, isPosixPath, isUrl, isVolume, isWindowsPath, split, } from \"./util.ts\";\nexport { isWindowsPath, isPosixPath, isUrl, isFileUrl, isAbsolute, endsWith };\n/**\n * Platform-specific path segment separator.\n * @experimental\n */\nexport const sep = (() => {\n    var _a, _b;\n    if (typeof Deno === \"object\" && typeof ((_a = Deno.build) === null || _a === void 0 ? void 0 : _a.os) === \"string\") { // Deno\n        if (Deno.build.os === \"windows\") {\n            return \"\\\\\";\n        }\n    }\n    else if (typeof process === \"object\" && !!((_b = process.versions) === null || _b === void 0 ? void 0 : _b.node)) { // Node.js\n        if (process.platform === \"win32\") {\n            return \"\\\\\";\n        }\n    }\n    return \"/\";\n})();\n/**\n * Returns the current working directory.\n * @experimental\n */\nexport function cwd() {\n    if (typeof Deno === \"object\" && typeof Deno.cwd === \"function\") {\n        return Deno.cwd();\n    }\n    else if (typeof process === \"object\" && typeof process.cwd === \"function\") {\n        return process.cwd();\n    }\n    else if (typeof location === \"object\" && location.origin) {\n        return location.origin + (location.pathname === \"/\" ? \"\" : location.pathname);\n    }\n    else {\n        throw new Error(\"Unable to determine the current working directory.\");\n    }\n}\n/**\n * Concatenates all given `segments` into a well-formed path.\n * @experimental\n */\nexport function join(...segments) {\n    segments = segments.filter(s => s !== \"\");\n    if (!segments.length) {\n        return \".\";\n    }\n    const paths = [];\n    for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        for (const _segment of split(segment)) {\n            if (_segment === \"..\") {\n                if (!paths.length || paths.every(p => p === \"..\")) {\n                    paths.push(\"..\");\n                }\n                else if (paths.length > 1 || (paths[0] !== \"/\" && !isVolume(paths[0]))) {\n                    paths.pop();\n                }\n            }\n            else if (_segment && _segment !== \".\") {\n                paths.push(_segment);\n            }\n        }\n    }\n    const start = paths[0];\n    const _sep = isUrl(start) || isPosixPath(start) ? \"/\" : isWindowsPath(start) ? \"\\\\\" : sep;\n    let path = \"\";\n    for (let i = 0; i < paths.length; i++) {\n        const segment = paths[i];\n        if (segment) {\n            if (!path) {\n                path = segment;\n            }\n            else if (segment[0] === \"?\" || segment[0] === \"#\") {\n                path += segment;\n            }\n            else if (path === \"/\") {\n                path += trim(segment, \"/\\\\\");\n            }\n            else if (isVolume(path)) {\n                path += isVolume(path, true) ? \"\\\\\" + segment : segment;\n            }\n            else if (segment) {\n                path += _sep + trim(segment, \"/\\\\\");\n            }\n        }\n    }\n    return path || \".\";\n}\nfunction _normalize(...segments) {\n    const path = join(...segments);\n    return isFileProtocol(path) ? path + \"/\" : path;\n}\n/**\n * Normalizes the given `path`, resolving `..` and `.` segments. Note that\n * resolving these segments does not necessarily mean that all will be\n * eliminated. A `..` at the top-level will be preserved, and an empty path is\n * canonically `.`.\n * @experimental\n */\nexport function normalize(path) {\n    return _normalize(path);\n}\n/**\n * Similar to {@link normalize}, but also remove the search string and hash string if\n * present.\n */\nexport function sanitize(path) {\n    return _normalize(...split(path).filter(isNotQuery));\n}\n/**\n * Resolves path `segments` into a well-formed path.\n * @experimental\n */\nexport function resolve(...segments) {\n    segments = segments.filter(s => s !== \"\");\n    const _cwd = cwd();\n    if (!segments.length) {\n        return _cwd;\n    }\n    segments = isAbsolute(segments[0]) ? segments : [_cwd, ...segments];\n    let _paths = [];\n    for (let i = 0; i < segments.length; i++) {\n        const path = segments[i];\n        if (isAbsolute(path)) {\n            _paths = [];\n        }\n        _paths.push(path);\n    }\n    return _normalize(..._paths);\n}\n/**\n * Returns the parent path of the given `path`.\n * @experimental\n */\nexport function dirname(path) {\n    if (isUrl(path)) {\n        const { protocol, host, pathname } = new URL(path);\n        const origin = protocol + \"//\" + host;\n        const _dirname = dirname(pathname);\n        if (_dirname === \"/\") {\n            return isFileProtocol(origin) ? origin + \"/\" : origin;\n        }\n        else {\n            return origin + _dirname;\n        }\n    }\n    else {\n        const segments = split(path).filter(isNotQuery);\n        const last = segments.pop();\n        if (segments.length) {\n            return join(...segments);\n        }\n        else if (last === \"/\") {\n            return \"/\";\n        }\n        else if (isVolume(last, true)) {\n            return last + \"\\\\\";\n        }\n        else if (isVolume(last)) {\n            return last;\n        }\n        else {\n            return \".\";\n        }\n    }\n}\n/**\n * Return the last portion of the given `path`. Trailing directory separators\n * are ignored, and optional `suffix` is removed.\n * @experimental\n */\nexport function basename(path, suffix = \"\") {\n    if (isUrl(path)) {\n        const { pathname } = new URL(path);\n        return basename(pathname, suffix);\n    }\n    else {\n        const segments = split(path).filter(isNotQuery);\n        const _basename = segments.pop();\n        if (!_basename || _basename === \"/\" || isVolume(_basename)) {\n            return \"\";\n        }\n        else if (suffix) {\n            return stripEnd(_basename, suffix);\n        }\n        else {\n            return _basename;\n        }\n    }\n}\n/**\n * Returns the extension of the `path` with leading period.\n * @experimental\n */\nexport function extname(path) {\n    const base = basename(path);\n    const index = base.lastIndexOf(\".\");\n    if (index === -1) {\n        return \"\";\n    }\n    else {\n        return base.slice(index);\n    }\n}\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"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"}